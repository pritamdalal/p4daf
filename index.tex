% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{5}
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newlength{\cslentryspacingunit} % times entry-spacing
\setlength{\cslentryspacingunit}{\parskip}
\newenvironment{CSLReferences}[2] % #1 hanging-ident, #2 entry spacing
 {% don't indent paragraphs
  \setlength{\parindent}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
  \let\oldpar\par
  \def\par{\hangindent=\cslhangindent\oldpar}
  \fi
  % set entry spacing
  \setlength{\parskip}{#2\cslentryspacingunit}
 }%
 {}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{#1\hfill\break}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{#1}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{#1}\break}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}

\KOMAoption{captions}{tableheading}
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\makeatother
\makeatletter
\@ifundefined{shadecolor}{\definecolor{shadecolor}{rgb}{.97, .97, .97}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\makeatother
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Python for Data Analysis in Finance},
  pdfauthor={Pritam Dalal},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{Python for Data Analysis in Finance}
\author{Pritam Dalal}
\date{}

\begin{document}
\maketitle
\ifdefined\Shaded\renewenvironment{Shaded}{\begin{tcolorbox}[sharp corners, boxrule=0pt, interior hidden, breakable, enhanced, frame hidden, borderline west={3pt}{0pt}{shadecolor}]}{\end{tcolorbox}}\fi

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\bookmarksetup{startatroot}

\hypertarget{preface}{%
\chapter*{Preface}\label{preface}}
\addcontentsline{toc}{chapter}{Preface}

\markboth{Preface}{Preface}

This is a Quarto book.

To learn more about Quarto books visit
\url{https://quarto.org/docs/books}.

\bookmarksetup{startatroot}

\hypertarget{python-jumpstart}{%
\chapter{Python Jumpstart}\label{python-jumpstart}}

The purpose of this chapter is to introduce \emph{Jupyter notebook}
files and to give a glimpse of how to use them to work with financial
data.

In particular, we will visualize stock index data to observe the
leverage effect: when the market suffers losses, prices become more
volatile.

We will move quickly without explaining all the details, so don't worry
if you aren't able to follow everything. It may be worth coming back to
this after you have completed the \emph{Basic Data Wrangling} part of
the the book.

\hypertarget{what-is-a-jupyter-notebook}{%
\section{What is a Jupyter Notebook?}\label{what-is-a-jupyter-notebook}}

The notebook format conveniently allows you to combine sentences, code,
code outputs (including plots), and mathematical notation. Notebooks
have proven to be a convenient and productive programming environment
for data analysis.

Behind the scenes of a Jupyter notebook is a \emph{kernel} that is
responsible for executing computations. The kernel can live locally on
your machine or on a remote server.

\hypertarget{ides-for-jupyter-notebooks}{%
\section{IDEs for Jupyter Notebooks}\label{ides-for-jupyter-notebooks}}

You will need another piece of software called an \emph{integrated
development environment} (IDE) to actually work with Jupyter notebooks;
here are three popular and free IDEs for working with them:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{https://jupyter.org/}{JupyterLab} - my personal favorite,
  created by the Jupyter project, which also creates the Jupyter
  notebook format.
\item
  \href{https://jupyter.org/}{Jupyter Notebook Classic} - this was the
  predecessor to JupyterLab, also created by the Jupyter project.
\item
  \href{https://code.visualstudio.com/}{VSCode} - an general purpose IDE
  created my Microsoft.
\end{enumerate}

\hypertarget{code-cells}{%
\section{Code Cells}\label{code-cells}}

A notebook is structured as a sequence of \emph{cells}. There are three
kinds of cells: 1) \emph{code} cells that contain code; 2)
\emph{markdown} cells that contain markdown or latex; and 3) \emph{raw}
cells that contain raw text. We will work mainly with code cells and
markdown cells.

The cell below is a code cell - try typing the code and then press
\textbf{shift + enter}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ IPython.display }\ImportTok{import}\NormalTok{ Image}
\NormalTok{Image(}\StringTok{"not\_ethical.png"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{chapters/01_jumpstart/jumpstart_files/figure-pdf/cell-2-output-1.png}

}

\end{figure}

\hypertarget{edit-mode-vs-command-mode}{%
\section{Edit Mode vs Command Mode}\label{edit-mode-vs-command-mode}}

There are two modes in a notebook: 1) \textbf{edit} mode; 2)
\textbf{command} mode.

In \textbf{edit} mode you are \emph{inside} a cell and you can edit the
contents of the cell.

In \textbf{command} mode, you are \emph{outside} the cells and you can
navigate between them.

\hypertarget{keyboard-shortcuts}{%
\section{Keyboard Shortcuts}\label{keyboard-shortcuts}}

Here are some of my favorite JupyterLab keyboard shortcuts:

edit mode: \textbf{enter}

command mode: \textbf{esc}

navigate up: \textbf{k}

navigate down: \textbf{j}

insert cell above: \textbf{a}

insert cell below: \textbf{b}

delete cell: \textbf{d, d} (press \textbf{d} twice)

switch to code cell: \textbf{y}

switch to markup cell: \textbf{m}

execute and stay on current cell: \textbf{ctrl + enter}

execute and move down a cell: \textbf{shift + enter}

\hypertarget{drop-down-menus}{%
\section{Drop Down Menus}\label{drop-down-menus}}

Here are a few of the drop down menu functions in JupyterLab that I use
frequently:

\emph{Kernel \textgreater{} Restart Kernel and Clear All Outputs}

\emph{Kernel \textgreater{} Restart Kearnel and Run All Cells}

\emph{Run \textgreater{} Run All Above Selected Cell}

\hypertarget{importing-packages}{%
\section{Importing Packages}\label{importing-packages}}

The power and convenience of Python as a data analysis language comes
from the ecosystem of freely available third party packages.

Here are the packages that we will be using in this tutorial:

\textbf{numpy} - efficient vector and matrix computations

\textbf{pandas} - working with \texttt{DataFrames}

\textbf{yfinance} - reading in data from Yahoo finance

\textbf{pandas\_datareader} - also for reading data from Yahoo Finance

The following code imports these packages and assigns them each an
alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ yfinance }\ImportTok{as}\NormalTok{ yf}
\NormalTok{yf.pdr\_override()}
\ImportTok{from}\NormalTok{ pandas\_datareader }\ImportTok{import}\NormalTok{ data }\ImportTok{as}\NormalTok{ pdr}
\end{Highlighting}
\end{Shaded}

\hypertarget{reading-in-stock-data-into-a-dataframe}{%
\section{\texorpdfstring{Reading-In Stock Data into a
\texttt{DataFrame}}{Reading-In Stock Data into a DataFrame}}\label{reading-in-stock-data-into-a-dataframe}}

Let's begin by reading in 5 years of SPY price data from Yahoo Finance.

SPY is an ETF that tracks the performace of the SP500 stock index.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy }\OperatorTok{=}\NormalTok{ pdr.get\_data\_yahoo(}\StringTok{\textquotesingle{}SPY\textquotesingle{}}\NormalTok{, start}\OperatorTok{=}\StringTok{\textquotesingle{}2014{-}01{-}01\textquotesingle{}}\NormalTok{, end}\OperatorTok{=}\StringTok{\textquotesingle{}2019{-}01{-}01\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_spy }\OperatorTok{=}\NormalTok{ df\_spy.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[*********************100%***********************]  1 of 1 completed
\end{verbatim}

\begin{longtable}[]{@{}lllllll@{}}
\toprule\noalign{}
& Open & High & Low & Close & Adj Close & Volume \\
Date & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2014-01-02 & 183.98 & 184.07 & 182.48 & 182.92 & 153.83 & 119636900 \\
2014-01-03 & 183.23 & 183.60 & 182.63 & 182.89 & 153.80 & 81390600 \\
2014-01-06 & 183.49 & 183.56 & 182.08 & 182.36 & 153.36 & 108028200 \\
2014-01-07 & 183.09 & 183.79 & 182.95 & 183.48 & 154.30 & 86144200 \\
2014-01-08 & 183.45 & 183.83 & 182.89 & 183.52 & 154.33 & 96582300 \\
\end{longtable}

Our stock data now lives in the variable called \texttt{df\_spy}, which
is a \textbf{pandas} data structure known as a \texttt{DataFrame}. We
can see this by using the following code:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(df\_spy)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pandas.core.frame.DataFrame
\end{verbatim}

\hypertarget{dataframe-index}{%
\section{\texorpdfstring{\texttt{DataFrame}
Index}{DataFrame Index}}\label{dataframe-index}}

In \textbf{pandas}, a \texttt{DataFrame} always has an index. For
\texttt{df\_spy} the \texttt{Dates} form the index.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.index}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
DatetimeIndex(['2014-01-02', '2014-01-03', '2014-01-06', '2014-01-07',
               '2014-01-08', '2014-01-09', '2014-01-10', '2014-01-13',
               '2014-01-14', '2014-01-15',
               ...
               '2018-12-17', '2018-12-18', '2018-12-19', '2018-12-20',
               '2018-12-21', '2018-12-24', '2018-12-26', '2018-12-27',
               '2018-12-28', '2018-12-31'],
              dtype='datetime64[ns]', name='Date', length=1258, freq=None)
\end{verbatim}

I don't use indices very much, so let's make the \texttt{Date} index
just a regular column. Notice that we can modify \texttt{DataFrames}
inplace.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.reset\_index(inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{df\_spy}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& Date & Open & High & Low & Close & Adj Close & Volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2014-01-02 & 183.98 & 184.07 & 182.48 & 182.92 & 153.83 &
119636900 \\
1 & 2014-01-03 & 183.23 & 183.60 & 182.63 & 182.89 & 153.80 &
81390600 \\
2 & 2014-01-06 & 183.49 & 183.56 & 182.08 & 182.36 & 153.36 &
108028200 \\
3 & 2014-01-07 & 183.09 & 183.79 & 182.95 & 183.48 & 154.30 &
86144200 \\
4 & 2014-01-08 & 183.45 & 183.83 & 182.89 & 183.52 & 154.33 &
96582300 \\
... & ... & ... & ... & ... & ... & ... & ... \\
1253 & 2018-12-24 & 239.04 & 240.84 & 234.27 & 234.34 & 217.60 &
147311600 \\
1254 & 2018-12-26 & 235.97 & 246.18 & 233.76 & 246.18 & 228.59 &
218485400 \\
1255 & 2018-12-27 & 242.57 & 248.29 & 238.96 & 248.07 & 230.35 &
186267300 \\
1256 & 2018-12-28 & 249.58 & 251.40 & 246.45 & 247.75 & 230.05 &
153100200 \\
1257 & 2018-12-31 & 249.56 & 250.19 & 247.47 & 249.92 & 232.07 &
144299400 \\
\end{longtable}

Notice that even though we ran the \texttt{.reset\_index()} method of
\texttt{df\_spy} it still has an index; now its index is just a sequence
of integers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.index}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
RangeIndex(start=0, stop=1258, step=1)
\end{verbatim}

\hypertarget{a-bit-of-cleaning}{%
\section{A Bit of Cleaning}\label{a-bit-of-cleaning}}

As a matter of preference, I like my column names to be in snake case.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.columns }\OperatorTok{=}\NormalTok{ df\_spy.columns.}\BuiltInTok{str}\NormalTok{.lower().}\BuiltInTok{str}\NormalTok{.replace(}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}\_\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2014-01-02 & 183.98 & 184.07 & 182.48 & 182.92 & 153.83 &
119636900 \\
1 & 2014-01-03 & 183.23 & 183.60 & 182.63 & 182.89 & 153.80 &
81390600 \\
2 & 2014-01-06 & 183.49 & 183.56 & 182.08 & 182.36 & 153.36 &
108028200 \\
3 & 2014-01-07 & 183.09 & 183.79 & 182.95 & 183.48 & 154.30 &
86144200 \\
4 & 2014-01-08 & 183.45 & 183.83 & 182.89 & 183.52 & 154.33 &
96582300 \\
\end{longtable}

Let's also remove the columns that we won't need. We first create a
\texttt{list} of the column names that we want to get rid of and then we
use the \texttt{DataFrame.drop()} method.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst\_cols }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{,]}
\NormalTok{df\_spy.drop(columns}\OperatorTok{=}\NormalTok{lst\_cols, inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& date & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2014-01-02 & 153.83 \\
1 & 2014-01-03 & 153.80 \\
2 & 2014-01-06 & 153.36 \\
3 & 2014-01-07 & 154.30 \\
4 & 2014-01-08 & 154.33 \\
\end{longtable}

Notice that trailing commas do not cause errors in Python.

\hypertarget{series}{%
\section{\texorpdfstring{\texttt{Series}}{Series}}\label{series}}

You can isolate the columns of a \texttt{DataFrame} with square brackets
as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0       153.83
1       153.80
2       153.36
3       154.30
4       154.33
         ...  
1253    217.60
1254    228.59
1255    230.35
1256    230.05
1257    232.07
Name: adj_close, Length: 1258, dtype: float64
\end{verbatim}

The columns of a \texttt{DataFrame} are a \textbf{pandas} data structure
called a \texttt{Series}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(df\_spy[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pandas.core.series.Series
\end{verbatim}

\hypertarget{numpy-and-ndarrays}{%
\section{\texorpdfstring{\textbf{numpy} and
\texttt{ndarrays}}{numpy and ndarrays}}\label{numpy-and-ndarrays}}

Python is a general purpose programming language and was not created for
scientific computing in particular. One of the foundational packages
that makes Python well suited to scientific computing is \textbf{numpy},
which has a variety of features including a data type called
\texttt{ndarrays}. One of the benefits of \texttt{ndarrays} is that they
allow for efficient vector and matrix computation.

The \texttt{values} of a \texttt{Series} object is a
\texttt{numpy.ndarray}. This is one sense in which \textbf{pandas} is
\emph{built on top of} \texttt{numpy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{].values}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([153.83, 153.8 , 153.36, ..., 230.35, 230.05, 232.07])
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(df\_spy[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{].values)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
numpy.ndarray
\end{verbatim}

\hypertarget{series-built-in-methods}{%
\section{\texorpdfstring{\texttt{Series} Built-In
Methods}{Series Built-In Methods}}\label{series-built-in-methods}}

\texttt{Series} have a variety of built-in methods that provide
convenient summarization and modification functionality. For example,
you can \texttt{.sum()} all the elements of the \texttt{Series}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
251297.16
\end{verbatim}

Next, we calculate the standard deviation of all the elements of the
\texttt{Series} using the \texttt{.std()} method.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{].std()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
33.16746781625381
\end{verbatim}

The \texttt{.shift()} built-in method will be useful for calculating
returns in the next section - it has the effect of \emph{pushing down}
the values in a \texttt{Series}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{].shift()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0          NaN
1       153.83
2       153.80
3       153.36
4       154.30
         ...  
1253    223.51
1254    217.60
1255    228.59
1256    230.35
1257    230.05
Name: adj_close, Length: 1258, dtype: float64
\end{verbatim}

\hypertarget{calculating-daily-returns}{%
\section{Calculating Daily Returns}\label{calculating-daily-returns}}

Our analysis analysis of the leverage effect will involve daily returns
for all the days in \texttt{df\_spy}. Let's calculate those now.

Recall that the end-of-day day \(t\) return of a stock is defined as:
\(r_{t} = \frac{S_{t}}{S_{t-1}} - 1\), where \(S_{t}\) is the stock
price at end-of-day \(t\).

Here is a vectorized approach to calculating all the daily returns in a
single line of code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}ret\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ df\_spy[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{] }\OperatorTok{/}\NormalTok{ df\_spy[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{].shift(}\DecValTok{1}\NormalTok{) }\OperatorTok{{-}} \DecValTok{1}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& date & adj\_close & ret \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2014-01-02 & 153.83 & NaN \\
1 & 2014-01-03 & 153.80 & -0.000195 \\
2 & 2014-01-06 & 153.36 & -0.002861 \\
3 & 2014-01-07 & 154.30 & 0.006129 \\
4 & 2014-01-08 & 154.33 & 0.000194 \\
\end{longtable}

Notice that we can create a new column of a \texttt{DataFrame} by using
variable assignment syntax.

\hypertarget{visualizing-adjusted-close-prices}{%
\section{Visualizing Adjusted Close
Prices}\label{visualizing-adjusted-close-prices}}

Python has a variety of packages that can be used for visualization. In
this chapter we will focus on built-in plotting capabilities of
\textbf{pandas}. These capabilities are built on top of the
\textbf{matplotlib} package, which is the foundation of much of Python's
visualization ecosystem.

\texttt{DataFrames} have a built-in \texttt{.plot()} method that makes
creating simple line graphs quite easy.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.plot(x}\OperatorTok{=}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, y}\OperatorTok{=}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{chapters/01_jumpstart/jumpstart_files/figure-pdf/cell-19-output-1.png}

}

\end{figure}

If we wanted to make this graph more presentable we could do something
like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ax }\OperatorTok{=}\NormalTok{ df\_spy.}\OperatorTok{\textbackslash{}}
\NormalTok{        plot(}
\NormalTok{            x }\OperatorTok{=} \StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{,}
\NormalTok{            y }\OperatorTok{=} \StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{,}
\NormalTok{            title }\OperatorTok{=} \StringTok{\textquotesingle{}SPY: 2014{-}2018\textquotesingle{}}\NormalTok{,}
\NormalTok{            grid }\OperatorTok{=} \VariableTok{True}\NormalTok{,}
\NormalTok{            style }\OperatorTok{=} \StringTok{\textquotesingle{}k\textquotesingle{}}\NormalTok{,}
\NormalTok{            alpha }\OperatorTok{=} \FloatTok{0.75}\NormalTok{,}
\NormalTok{            figsize }\OperatorTok{=}\NormalTok{ (}\DecValTok{9}\NormalTok{, }\DecValTok{4}\NormalTok{),}
\NormalTok{        )}\OperatorTok{;}
\NormalTok{ax.set\_xlabel(}\StringTok{\textquotesingle{}Trade Date\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{ax.set\_ylabel(}\StringTok{\textquotesingle{}Close Price\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{chapters/01_jumpstart/jumpstart_files/figure-pdf/cell-20-output-1.png}

}

\end{figure}

Notice that the \texttt{ax} variable created above is a
\texttt{matplotlib} object.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(ax)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
matplotlib.axes._axes.Axes
\end{verbatim}

\hypertarget{visualizing-returns}{%
\section{Visualizing Returns}\label{visualizing-returns}}

\textbf{pandas} also gives us the ability to simultaneously plot two
different columns of a \texttt{DataFrame} in separate subplots of a
single graph. Here is what that code looks like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.plot(x}\OperatorTok{=}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, y}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}ret\textquotesingle{}}\NormalTok{,], subplots}\OperatorTok{=}\VariableTok{True}\NormalTok{, style}\OperatorTok{=}\StringTok{\textquotesingle{}k\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.75}\NormalTok{, figsize}\OperatorTok{=}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{), grid}\OperatorTok{=}\VariableTok{True}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{chapters/01_jumpstart/jumpstart_files/figure-pdf/cell-22-output-1.png}

}

\end{figure}

The \texttt{returns} graph above is a bit of a hack, it doesn't really
make sense to create a line graph of consecutive returns. However,
because there are so many days jammed into the x-axis, it creates a
desirable effect and it used all the time in finance to demonstrate
properties of volatility.

Notice that whenever there is a sharp drop in the \texttt{adj\_close}
price graph, that the magnitude of the nearby returns becomes large. In
contrast, during periods of steady growth (e.g.~all of 2017) the
magnitude of the returns is small. This is precisely the leverage
effect.

\hypertarget{calculating-realized-volatility}{%
\section{Calculating Realized
Volatility}\label{calculating-realized-volatility}}

Realized volatility is defined as the standard deviation of the daily
returns; it indicates how much variability in the stock price there has
been. It is a matter of convention to annualize this quantity, so we
multiply it by \(\sqrt{252}\).

The following vectorized code calculates a rolling 2-month volatility
for our SPY price data.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}ret\textquotesingle{}}\NormalTok{].rolling(}\DecValTok{42}\NormalTok{).std() }\OperatorTok{*}\NormalTok{ np.sqrt(}\DecValTok{252}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0            NaN
1            NaN
2            NaN
3            NaN
4            NaN
          ...   
1253    0.226735
1254    0.252813
1255    0.249195
1256    0.246019
1257    0.247027
Name: ret, Length: 1258, dtype: float64
\end{verbatim}

Let's add these realized volatility calculations to\texttt{df\_spy} this
with the following code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}realized\_vol\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ df\_spy[}\StringTok{\textquotesingle{}ret\textquotesingle{}}\NormalTok{].rolling(}\DecValTok{42}\NormalTok{).std() }\OperatorTok{*}\NormalTok{ np.sqrt(}\DecValTok{252}\NormalTok{)}
\NormalTok{df\_spy}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& date & adj\_close & ret & realized\_vol \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2014-01-02 & 153.83 & NaN & NaN \\
1 & 2014-01-03 & 153.80 & -0.000195 & NaN \\
2 & 2014-01-06 & 153.36 & -0.002861 & NaN \\
3 & 2014-01-07 & 154.30 & 0.006129 & NaN \\
4 & 2014-01-08 & 154.33 & 0.000194 & NaN \\
... & ... & ... & ... & ... \\
1253 & 2018-12-24 & 217.60 & -0.026442 & 0.226735 \\
1254 & 2018-12-26 & 228.59 & 0.050506 & 0.252813 \\
1255 & 2018-12-27 & 230.35 & 0.007699 & 0.249195 \\
1256 & 2018-12-28 & 230.05 & -0.001302 & 0.246019 \\
1257 & 2018-12-31 & 232.07 & 0.008781 & 0.247027 \\
\end{longtable}

\hypertarget{visualizing-realized-volatility}{%
\section{Visualizing Realized
Volatility}\label{visualizing-realized-volatility}}

We can easily add \texttt{realized\_vol} to our graph with the following
code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, }
\NormalTok{            y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}ret\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}realized\_vol\textquotesingle{}}\NormalTok{,], }
\NormalTok{            subplots}\OperatorTok{=}\VariableTok{True}\NormalTok{, style}\OperatorTok{=}\StringTok{\textquotesingle{}k\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.75}\NormalTok{, }
\NormalTok{            figsize}\OperatorTok{=}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{12}\NormalTok{), }
\NormalTok{            grid}\OperatorTok{=}\VariableTok{True}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{chapters/01_jumpstart/jumpstart_files/figure-pdf/cell-25-output-1.png}

}

\end{figure}

This graph is an excellent illustration of the leverage effect. When SPY
suffers losses, there is a spike in realized volatility, which is to say
that the magnitude of the nearby returns increases.

\hypertarget{further-reading}{%
\section{Further Reading}\label{further-reading}}

\emph{Python Data Science Handbook} - Jake VanderPlas

\emph{Python for Finance 2e} - Yves Hilpisch

\emph{Python for Data Analysis 3e} - Wes McKinney

\bookmarksetup{startatroot}

\hypertarget{dataframe-basics}{%
\chapter{\texorpdfstring{\texttt{DataFrame}
Basics}{DataFrame Basics}}\label{dataframe-basics}}

In this chapter we cover the basics of working with \texttt{DataFrames}
in \textbf{pandas}.

\hypertarget{importing-packages-1}{%
\section{Importing Packages}\label{importing-packages-1}}

Let's begin by importing the packages that we will need.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ yfinance }\ImportTok{as}\NormalTok{ yf}
\NormalTok{yf.pdr\_override()}
\ImportTok{from}\NormalTok{ pandas\_datareader }\ImportTok{import}\NormalTok{ data }\ImportTok{as}\NormalTok{ pdr}
\NormalTok{pd.set\_option(}\StringTok{\textquotesingle{}display.max\_rows\textquotesingle{}}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{reading-in-data}{%
\section{Reading-In Data}\label{reading-in-data}}

Next, let's use \textbf{pandas\_datareader} to read-in SPY prices from
March 2020. SPY is an ETF that tracks the S\&P500 index.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy }\OperatorTok{=}\NormalTok{ pdr.get\_data\_yahoo(}\StringTok{\textquotesingle{}SPY\textquotesingle{}}\NormalTok{, start}\OperatorTok{=}\StringTok{\textquotesingle{}2020{-}02{-}28\textquotesingle{}}\NormalTok{, end}\OperatorTok{=}\StringTok{\textquotesingle{}2020{-}03{-}31\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_spy }\OperatorTok{=}\NormalTok{ df\_spy.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[*********************100%***********************]  1 of 1 completed
\end{verbatim}

\begin{longtable}[]{@{}lllllll@{}}
\toprule\noalign{}
& Open & High & Low & Close & Adj Close & Volume \\
Date & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2020-02-28 & 288.70 & 297.89 & 285.54 & 296.26 & 280.31 & 384975800 \\
2020-03-02 & 298.21 & 309.16 & 294.46 & 309.09 & 292.45 & 238703600 \\
2020-03-03 & 309.50 & 313.84 & 297.57 & 300.24 & 284.07 & 300139100 \\
2020-03-04 & 306.12 & 313.10 & 303.33 & 312.86 & 296.01 & 176613400 \\
2020-03-05 & 304.98 & 308.47 & 300.01 & 302.46 & 286.17 & 186366800 \\
\end{longtable}

Let's also make the \texttt{Date} a regular column, instead of an index,
and also make the column names snake-case.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.reset\_index(drop}\OperatorTok{=}\VariableTok{False}\NormalTok{, inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{df\_spy.columns }\OperatorTok{=}\NormalTok{ df\_spy.columns.}\BuiltInTok{str}\NormalTok{.lower().}\BuiltInTok{str}\NormalTok{.replace(}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\_\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-02-28 & 288.70 & 297.89 & 285.54 & 296.26 & 280.31 &
384975800 \\
1 & 2020-03-02 & 298.21 & 309.16 & 294.46 & 309.09 & 292.45 &
238703600 \\
2 & 2020-03-03 & 309.50 & 313.84 & 297.57 & 300.24 & 284.07 &
300139100 \\
3 & 2020-03-04 & 306.12 & 313.10 & 303.33 & 312.86 & 296.01 &
176613400 \\
4 & 2020-03-05 & 304.98 & 308.47 & 300.01 & 302.46 & 286.17 &
186366800 \\
\end{longtable}

\hypertarget{exploring-a-dataframe}{%
\section{\texorpdfstring{Exploring a
\texttt{DataFrame}}{Exploring a DataFrame}}\label{exploring-a-dataframe}}

We can explore our \texttt{df\_spy} \texttt{DataFrame} in a variety of
ways.

First, we can first use the \texttt{type()} method to make sure what we
have created is in fact a \texttt{DataFrame}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(df\_spy)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pandas.core.frame.DataFrame
\end{verbatim}

Next, we can use the \texttt{.dtypes} attribute of the
\texttt{DataFrame} to see the data types of each of the columns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.dtypes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
date         datetime64[ns]
open                float64
high                float64
low                 float64
close               float64
adj_close           float64
volume                int64
dtype: object
\end{verbatim}

We can also check the number of rows and columns by using the
\texttt{.shape} attribute.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.shape}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(22, 7)
\end{verbatim}

As we can see, our \texttt{DataFrame} \texttt{df\_spy} consists of 22
rows and 7 columns.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Try the \texttt{DataFrame.info()} and
\texttt{DataFrame.describe()} methods on \texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.info()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 22 entries, 0 to 21
Data columns (total 7 columns):
 #   Column     Non-Null Count  Dtype         
---  ------     --------------  -----         
 0   date       22 non-null     datetime64[ns]
 1   open       22 non-null     float64       
 2   high       22 non-null     float64       
 3   low        22 non-null     float64       
 4   close      22 non-null     float64       
 5   adj_close  22 non-null     float64       
 6   volume     22 non-null     int64         
dtypes: datetime64[ns](1), float64(5), int64(1)
memory usage: 1.3 KB
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.describe().}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
count & 22 & 22.00 & 22.00 & 22.00 & 22.00 & 22.00 & 2.200000e+01 \\
mean & 2020-03-14 12:00:00 & 265.03 & 272.89 & 258.81 & 266.54 & 252.62
& 2.780051e+08 \\
min & 2020-02-28 00:00:00 & 228.19 & 229.68 & 218.26 & 222.95 & 212.18 &
1.713695e+08 \\
25\% & 2020-03-06 18:00:00 & 243.12 & 256.22 & 237.14 & 244.06 & 232.24
& 2.362968e+08 \\
50\% & 2020-03-14 12:00:00 & 255.85 & 264.73 & 250.05 & 261.42 & 248.80
& 2.828830e+08 \\
75\% & 2020-03-22 06:00:00 & 287.68 & 295.55 & 282.53 & 294.30 & 278.46
& 3.218732e+08 \\
max & 2020-03-30 00:00:00 & 309.50 & 313.84 & 303.33 & 312.86 & 296.01 &
3.922207e+08 \\
std & NaN & 26.43 & 25.44 & 26.98 & 27.55 & 25.74 & 6.134551e+07 \\
\end{longtable}

\hypertarget{dataframe-columns}{%
\section{\texorpdfstring{\texttt{DataFrame}
Columns}{DataFrame Columns}}\label{dataframe-columns}}

In order to isolate a particular column of a \texttt{DataFrame} we can
use square brackets (\texttt{{[}\ {]}}). The following code isolates the
\texttt{close} price column of \texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0     296.26
1     309.09
2     300.24
3     312.86
4     302.46
       ...  
17    243.15
18    246.79
19    261.20
20    253.42
21    261.65
Name: close, Length: 22, dtype: float64
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Isolate the \texttt{date} column of
\texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    2020-02-28
1    2020-03-02
2    2020-03-03
3    2020-03-04
4    2020-03-05
        ...    
17   2020-03-24
18   2020-03-25
19   2020-03-26
20   2020-03-27
21   2020-03-30
Name: date, Length: 22, dtype: datetime64[ns]
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

As we can see from the following code, each column of a
\texttt{DataFrame} is actually a different kind of \textbf{pandas}
structure called a \texttt{Series}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(df\_spy[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pandas.core.series.Series
\end{verbatim}

Here is a bit of \textbf{pandas} inside baseball:

\begin{itemize}
\item
  A \texttt{DataFrame} is collection of columns that are glued together.
\item
  Each column is a \texttt{Series}.
\item
  A \texttt{Series} has two main attributes: 1) \texttt{.values}; 2)
  \texttt{.index}.
\item
  The \texttt{.values} component of a \texttt{Series} is a
  \texttt{numpy.array}.
\end{itemize}

Let's look at the \texttt{.values} attribute of the \texttt{close}
column of \texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{].values}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([296.26, 309.09, 300.24, 312.86, 302.46, 297.46, 274.23, 288.42,
       274.36, 248.11, 269.32, 239.85, 252.8 , 240.  , 240.51, 228.8 ,
       222.95, 243.15, 246.79, 261.2 , 253.42, 261.65])
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Verify that the \texttt{values} component of
the \texttt{close} column of \texttt{df\_spy} is in fact a a
\texttt{numpy.array}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(df\_spy[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{].values)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
numpy.ndarray
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{component-wise-column-operations}{%
\section{Component-wise Column
Operations}\label{component-wise-column-operations}}

We can perform component-wise (i.e.~vector-like) calculations with
\texttt{DataFrame} columns.

The following code divides all the \texttt{close} prices by 100.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{] }\OperatorTok{/} \DecValTok{100}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0     2.9626
1     3.0909
2     3.0024
3     3.1286
4     3.0246
       ...  
17    2.4315
18    2.4679
19    2.6120
20    2.5342
21    2.6165
Name: close, Length: 22, dtype: float64
\end{verbatim}

We can also perform component-wise calculations between two colums.

Let's say we want to calculate the \emph{intraday range} of SPY for each
of the trade-dates in \texttt{df\_spy}; this is the difference between
the \texttt{high} and the \texttt{low} of each day. We can do this
easily from the columns of our \texttt{DataFrame}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ df\_spy[}\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0     12.35
1     14.70
2     16.27
3      9.77
4      8.46
      ...  
17    10.30
18    16.60
19    13.75
20     9.76
21     8.90
Length: 22, dtype: float64
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Calculate the difference between the
\texttt{close} and \texttt{open} columns of \texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ df\_spy[}\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0      7.56
1     10.88
2     -9.26
3      6.74
4     -2.52
      ...  
17     8.73
18     1.92
19    11.68
20     0.15
21     5.95
Length: 22, dtype: float64
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{adding-columns-via-variable-assignment}{%
\section{Adding Columns via Variable
Assignment}\label{adding-columns-via-variable-assignment}}

Let's say we want to save our intraday ranges back into \texttt{df\_spy}
for further analysis later. The most straightforward way to do this is
using variable assignment as follows.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}intraday\_range\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ df\_spy[}\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ df\_spy[}\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{]}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume &
intraday\_range \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-02-28 & 288.70 & 297.89 & 285.54 & 296.26 & 280.31 & 384975800
& 12.35 \\
1 & 2020-03-02 & 298.21 & 309.16 & 294.46 & 309.09 & 292.45 & 238703600
& 14.70 \\
2 & 2020-03-03 & 309.50 & 313.84 & 297.57 & 300.24 & 284.07 & 300139100
& 16.27 \\
3 & 2020-03-04 & 306.12 & 313.10 & 303.33 & 312.86 & 296.01 & 176613400
& 9.77 \\
4 & 2020-03-05 & 304.98 & 308.47 & 300.01 & 302.46 & 286.17 & 186366800
& 8.46 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Add a new column to \texttt{df\_spy} called
\texttt{open\_to\_close} that consists of the difference between the
\texttt{close} and \texttt{open} of each day.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}open\_to\_close\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ df\_spy[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ df\_spy[}\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{]}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume &
intraday\_range & open\_to\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-02-28 & 288.70 & 297.89 & 285.54 & 296.26 & 280.31 & 384975800
& 12.35 & 7.56 \\
1 & 2020-03-02 & 298.21 & 309.16 & 294.46 & 309.09 & 292.45 & 238703600
& 14.70 & 10.88 \\
2 & 2020-03-03 & 309.50 & 313.84 & 297.57 & 300.24 & 284.07 & 300139100
& 16.27 & -9.26 \\
3 & 2020-03-04 & 306.12 & 313.10 & 303.33 & 312.86 & 296.01 & 176613400
& 9.77 & 6.74 \\
4 & 2020-03-05 & 304.98 & 308.47 & 300.01 & 302.46 & 286.17 & 186366800
& 8.46 & -2.52 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{adding-columns-via-.assign}{%
\section{\texorpdfstring{Adding Columns via
\texttt{.assign()}}{Adding Columns via .assign()}}\label{adding-columns-via-.assign}}

A powerful but less intuitive way of adding a column to a
\texttt{DataFrame} uses the \texttt{.assign()} function, which makes use
of \texttt{lambda} functions (i.e.~anonymous functions).

The following code adds another column called
\texttt{intraday\_range\_assign}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.assign(intraday\_range\_assign }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ df: df[}\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ df[}\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume &
intraday\_range & open\_to\_close & intraday\_range\_assign \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-02-28 & 288.70 & 297.89 & 285.54 & 296.26 & 280.31 & 384975800
& 12.35 & 7.56 & 12.35 \\
1 & 2020-03-02 & 298.21 & 309.16 & 294.46 & 309.09 & 292.45 & 238703600
& 14.70 & 10.88 & 14.70 \\
2 & 2020-03-03 & 309.50 & 313.84 & 297.57 & 300.24 & 284.07 & 300139100
& 16.27 & -9.26 & 16.27 \\
3 & 2020-03-04 & 306.12 & 313.10 & 303.33 & 312.86 & 296.01 & 176613400
& 9.77 & 6.74 & 9.77 \\
4 & 2020-03-05 & 304.98 & 308.47 & 300.01 & 302.46 & 286.17 & 186366800
& 8.46 & -2.52 & 8.46 \\
... & ... & ... & ... & ... & ... & ... & ... & ... & ... & ... \\
17 & 2020-03-24 & 234.42 & 244.10 & 233.80 & 243.15 & 231.41 & 235494500
& 10.30 & 8.73 & 10.30 \\
18 & 2020-03-25 & 244.87 & 256.35 & 239.75 & 246.79 & 234.87 & 299430300
& 16.60 & 1.92 & 16.60 \\
19 & 2020-03-26 & 249.52 & 262.80 & 249.05 & 261.20 & 248.59 & 257632800
& 13.75 & 11.68 & 13.75 \\
20 & 2020-03-27 & 253.27 & 260.81 & 251.05 & 253.42 & 241.18 & 224341200
& 9.76 & 0.15 & 9.76 \\
21 & 2020-03-30 & 255.70 & 262.43 & 253.53 & 261.65 & 249.02 & 171369500
& 8.90 & 5.95 & 8.90 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Verify that the column
\texttt{intraday\_range\_assign} was not actually added to the
\texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume &
intraday\_range & open\_to\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-02-28 & 288.70 & 297.89 & 285.54 & 296.26 & 280.31 & 384975800
& 12.35 & 7.56 \\
1 & 2020-03-02 & 298.21 & 309.16 & 294.46 & 309.09 & 292.45 & 238703600
& 14.70 & 10.88 \\
2 & 2020-03-03 & 309.50 & 313.84 & 297.57 & 300.24 & 284.07 & 300139100
& 16.27 & -9.26 \\
3 & 2020-03-04 & 306.12 & 313.10 & 303.33 & 312.86 & 296.01 & 176613400
& 9.77 & 6.74 \\
4 & 2020-03-05 & 304.98 & 308.47 & 300.01 & 302.46 & 286.17 & 186366800
& 8.46 & -2.52 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

In order to add the \texttt{intraday\_range\_assign} column to
\texttt{df\_spy} we will need to reassign to it.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy }\OperatorTok{=}\NormalTok{ df\_spy.assign(intraday\_range\_assign }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ df: df[}\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ df[}\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{])}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume &
intraday\_range & open\_to\_close & intraday\_range\_assign \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-02-28 & 288.70 & 297.89 & 285.54 & 296.26 & 280.31 & 384975800
& 12.35 & 7.56 & 12.35 \\
1 & 2020-03-02 & 298.21 & 309.16 & 294.46 & 309.09 & 292.45 & 238703600
& 14.70 & 10.88 & 14.70 \\
2 & 2020-03-03 & 309.50 & 313.84 & 297.57 & 300.24 & 284.07 & 300139100
& 16.27 & -9.26 & 16.27 \\
3 & 2020-03-04 & 306.12 & 313.10 & 303.33 & 312.86 & 296.01 & 176613400
& 9.77 & 6.74 & 9.77 \\
4 & 2020-03-05 & 304.98 & 308.47 & 300.01 & 302.46 & 286.17 & 186366800
& 8.46 & -2.52 & 8.46 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Use \texttt{.assign()} to create a new column
in \texttt{df\_spy}, call it \texttt{open\_to\_close\_assign}, that
contains the difference between the \texttt{close} and \texttt{open}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy }\OperatorTok{=}\NormalTok{ df\_spy.assign(open\_to\_close\_assign }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ df: df[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ df[}\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{])}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume &
intraday\_range & open\_to\_close & intraday\_range\_assign &
open\_to\_close\_assign \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-02-28 & 288.70 & 297.89 & 285.54 & 296.26 & 280.31 & 384975800
& 12.35 & 7.56 & 12.35 & 7.56 \\
1 & 2020-03-02 & 298.21 & 309.16 & 294.46 & 309.09 & 292.45 & 238703600
& 14.70 & 10.88 & 14.70 & 10.88 \\
2 & 2020-03-03 & 309.50 & 313.84 & 297.57 & 300.24 & 284.07 & 300139100
& 16.27 & -9.26 & 16.27 & -9.26 \\
3 & 2020-03-04 & 306.12 & 313.10 & 303.33 & 312.86 & 296.01 & 176613400
& 9.77 & 6.74 & 9.77 & 6.74 \\
4 & 2020-03-05 & 304.98 & 308.47 & 300.01 & 302.46 & 286.17 & 186366800
& 8.46 & -2.52 & 8.46 & -2.52 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{method-chaining}{%
\section{Method Chaining}\label{method-chaining}}

The value of \texttt{.assign()} becomes clear when we start
\emph{chaining} methods together.

In order to see this let's first \texttt{drop} the columns that we
created.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst\_cols }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}intraday\_range\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}open\_to\_close\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}intraday\_range\_assign\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}open\_to\_close\_assign\textquotesingle{}}\NormalTok{]}
\NormalTok{df\_spy.drop(columns}\OperatorTok{=}\NormalTok{lst\_cols, inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-02-28 & 288.70 & 297.89 & 285.54 & 296.26 & 280.31 &
384975800 \\
1 & 2020-03-02 & 298.21 & 309.16 & 294.46 & 309.09 & 292.45 &
238703600 \\
2 & 2020-03-03 & 309.50 & 313.84 & 297.57 & 300.24 & 284.07 &
300139100 \\
3 & 2020-03-04 & 306.12 & 313.10 & 303.33 & 312.86 & 296.01 &
176613400 \\
4 & 2020-03-05 & 304.98 & 308.47 & 300.01 & 302.46 & 286.17 &
186366800 \\
\end{longtable}

The following code adds the \texttt{intraday} and and
\texttt{open\_to\_close} columns at the same time.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    (}
\NormalTok{    df\_spy}
\NormalTok{        .assign(intraday\_range }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ df: df[}\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ df[}\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{])}
\NormalTok{        .assign(open\_to\_close }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ df: df[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ df[}\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{])}
\NormalTok{    )}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume &
intraday\_range & open\_to\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-02-28 & 288.70 & 297.89 & 285.54 & 296.26 & 280.31 & 384975800
& 12.35 & 7.56 \\
1 & 2020-03-02 & 298.21 & 309.16 & 294.46 & 309.09 & 292.45 & 238703600
& 14.70 & 10.88 \\
2 & 2020-03-03 & 309.50 & 313.84 & 297.57 & 300.24 & 284.07 & 300139100
& 16.27 & -9.26 \\
3 & 2020-03-04 & 306.12 & 313.10 & 303.33 & 312.86 & 296.01 & 176613400
& 9.77 & 6.74 \\
4 & 2020-03-05 & 304.98 & 308.47 & 300.01 & 302.46 & 286.17 & 186366800
& 8.46 & -2.52 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Use \texttt{.assign()} to add a two new column
to \texttt{df\_spy}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  the difference between the \texttt{close} and \texttt{adj\_close}
\item
  the average of the \texttt{low} and \texttt{open}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    (}
\NormalTok{    df\_spy}
\NormalTok{        .assign(div }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ df: df[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ df[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{])}
\NormalTok{        .assign(avg }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ df: (df[}\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{] }\OperatorTok{+}\NormalTok{ df[}\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{]) }\OperatorTok{/} \DecValTok{2}\NormalTok{)}
\NormalTok{    )}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume &
intraday\_range & open\_to\_close & div & avg \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-02-28 & 288.70 & 297.89 & 285.54 & 296.26 & 280.31 & 384975800
& 12.35 & 7.56 & 15.95 & 287.120 \\
1 & 2020-03-02 & 298.21 & 309.16 & 294.46 & 309.09 & 292.45 & 238703600
& 14.70 & 10.88 & 16.64 & 296.335 \\
2 & 2020-03-03 & 309.50 & 313.84 & 297.57 & 300.24 & 284.07 & 300139100
& 16.27 & -9.26 & 16.17 & 303.535 \\
3 & 2020-03-04 & 306.12 & 313.10 & 303.33 & 312.86 & 296.01 & 176613400
& 9.77 & 6.74 & 16.85 & 304.725 \\
4 & 2020-03-05 & 304.98 & 308.47 & 300.01 & 302.46 & 286.17 & 186366800
& 8.46 & -2.52 & 16.29 & 302.495 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{aggregating-calulations-on-series}{%
\section{\texorpdfstring{Aggregating Calulations on
\texttt{Series}}{Aggregating Calulations on Series}}\label{aggregating-calulations-on-series}}

\texttt{Series} have a variety of built-in aggregation functions.

For example, we can use the following code to calculate the total SPY
volume during March 2020.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6116112300
\end{verbatim}

Here are some summary statistics on the \texttt{intraday\_range} column
that we added to our \texttt{DataFrame} earlier.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Mean:  "}\NormalTok{, df\_spy[}\StringTok{\textquotesingle{}intraday\_range\textquotesingle{}}\NormalTok{].mean()) }\CommentTok{\# average}
\BuiltInTok{print}\NormalTok{(}\StringTok{"St Dev: "}\NormalTok{, df\_spy[}\StringTok{\textquotesingle{}intraday\_range\textquotesingle{}}\NormalTok{].std()) }\CommentTok{\# standard deviation}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Min:    "}\NormalTok{ , df\_spy[}\StringTok{\textquotesingle{}intraday\_range\textquotesingle{}}\NormalTok{].}\BuiltInTok{min}\NormalTok{()) }\CommentTok{\# minimum}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Max:   "}\NormalTok{ , df\_spy[}\StringTok{\textquotesingle{}intraday\_range\textquotesingle{}}\NormalTok{].}\BuiltInTok{max}\NormalTok{()) }\CommentTok{\# maximum}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Mean:   14.077727272727275
St Dev:  4.28352428533215
Min:     8.460000000000036
Max:    22.960000000000008
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Calculate the average daily \texttt{volume} for
the trade dates in \texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{].mean()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
278005104.54545456
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{related-reading}{%
\section{Related Reading}\label{related-reading}}

\emph{Python Data Science Handbook} - Section 3.1 - Introducing Pandas
Objects

\emph{Python Data Science Handbook} - Section 2.1 - Understanding Data
Types in Python

\emph{Python Data Science Handbook} - Section 2.2 - The Basics of NumPy
Arrays

\emph{Python Data Science Handbook} - Section 2.3 - Computation on NumPy
Arrays: Universal Functions

\emph{Python Data Science Handbook} - Section 2.4 - Aggregations: Min,
Max, and Everything In Between

\bookmarksetup{startatroot}

\hypertarget{dataframe-indexing-and-slicing}{%
\chapter{\texorpdfstring{\texttt{DataFrame} Indexing and
Slicing}{DataFrame Indexing and Slicing}}\label{dataframe-indexing-and-slicing}}

Accessing a specific row of a \texttt{DataFrame} by its location is
referred to as \emph{indexing}. Accessing a sequence of contiguous rows
is referred to as \emph{slicing}.

The purpose of this chapter is to survey various methods for indexing
and slicing in \textbf{pandas}.

\hypertarget{importing-packages-2}{%
\section{Importing Packages}\label{importing-packages-2}}

Let's begin by importing the packages that we will need.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ yfinance }\ImportTok{as}\NormalTok{ yf}
\NormalTok{yf.pdr\_override()}
\ImportTok{from}\NormalTok{ pandas\_datareader }\ImportTok{import}\NormalTok{ data }\ImportTok{as}\NormalTok{ pdr}
\NormalTok{pd.set\_option(}\StringTok{\textquotesingle{}display.max\_rows\textquotesingle{}}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{reading-in-data-1}{%
\section{Reading-In Data}\label{reading-in-data-1}}

Next, lets grab some data from Yahoo finance. In particular, we'll grab
\texttt{SPY} price data from July 2021.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy }\OperatorTok{=}\NormalTok{ pdr.get\_data\_yahoo(}\StringTok{\textquotesingle{}SPY\textquotesingle{}}\NormalTok{, start}\OperatorTok{=}\StringTok{\textquotesingle{}2021{-}06{-}30\textquotesingle{}}\NormalTok{, end}\OperatorTok{=}\StringTok{\textquotesingle{}2021{-}07{-}31\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_spy }\OperatorTok{=}\NormalTok{ df\_spy.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[*********************100%***********************]  1 of 1 completed
\end{verbatim}

\begin{longtable}[]{@{}lllllll@{}}
\toprule\noalign{}
& Open & High & Low & Close & Adj Close & Volume \\
Date & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 & 64827900 \\
2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 & 53441000 \\
2021-07-02 & 431.67 & 434.10 & 430.52 & 433.72 & 420.77 & 57697700 \\
2021-07-06 & 433.78 & 434.01 & 430.01 & 432.93 & 420.00 & 68710400 \\
2021-07-07 & 433.66 & 434.76 & 431.51 & 434.46 & 421.49 & 63549500 \\
\end{longtable}

The following code resets the index so that \texttt{Date} is a regular
column; it also puts the column names into snake-case.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.reset\_index(inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{df\_spy.columns }\OperatorTok{=}\NormalTok{ df\_spy.columns.}\BuiltInTok{str}\NormalTok{.lower().}\BuiltInTok{str}\NormalTok{.replace(}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\_\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 &
64827900 \\
1 & 2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 &
53441000 \\
2 & 2021-07-02 & 431.67 & 434.10 & 430.52 & 433.72 & 420.77 &
57697700 \\
3 & 2021-07-06 & 433.78 & 434.01 & 430.01 & 432.93 & 420.00 &
68710400 \\
4 & 2021-07-07 & 433.66 & 434.76 & 431.51 & 434.46 & 421.49 &
63549500 \\
\end{longtable}

It is often useful to look at the data type of each of the columns of a
new data set. We can do so with the \texttt{DataFrame.dtypes} attribute.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.dtypes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
date         datetime64[ns]
open                float64
high                float64
low                 float64
close               float64
adj_close           float64
volume                int64
dtype: object
\end{verbatim}

\hypertarget{row-slicing}{%
\section{Row Slicing}\label{row-slicing}}

The simplest way to slice a \texttt{DataFrame} is to use square
brackets: \texttt{{[}{]}}. The syntax \texttt{df{[}i:j{]}} will generate
a \texttt{DataFrame} who's first row is the \texttt{i}th row of
\texttt{df} and who's last row is the \texttt{(j-1)}th row of
\texttt{df}. Let's demonstrate this with a some examples:

Starting from the 0th row, and ending with the 0th row:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\DecValTok{0}\NormalTok{:}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 &
64827900 \\
\end{longtable}

Starting with the 3rd row, and ending with the 6th row:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\DecValTok{3}\NormalTok{:}\DecValTok{7}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
3 & 2021-07-06 & 433.78 & 434.01 & 430.01 & 432.93 & 420.00 &
68710400 \\
4 & 2021-07-07 & 433.66 & 434.76 & 431.51 & 434.46 & 421.49 &
63549500 \\
5 & 2021-07-08 & 428.78 & 431.73 & 427.52 & 430.92 & 418.05 &
97595200 \\
6 & 2021-07-09 & 432.53 & 435.84 & 430.71 & 435.52 & 422.51 &
76238600 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Retrieve the 15th, 16th, and 17th rows of
\texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\DecValTok{15}\NormalTok{:}\DecValTok{18}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
15 & 2021-07-22 & 434.74 & 435.72 & 433.69 & 435.46 & 422.46 &
47878500 \\
16 & 2021-07-23 & 437.52 & 440.30 & 436.79 & 439.94 & 426.80 &
63766600 \\
17 & 2021-07-26 & 439.31 & 441.03 & 439.26 & 441.02 & 427.85 &
43719200 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Using the syntax \texttt{df{[}:n{]}} automatically starts the indexing
at \texttt{0}. For example, the following code retrieves all of
\texttt{df\_spy} (notice that \texttt{len(df\_spy)} gives the number of
rows of \texttt{df\_spy}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[:}\BuiltInTok{len}\NormalTok{(df\_spy)]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 &
64827900 \\
1 & 2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 &
53441000 \\
2 & 2021-07-02 & 431.67 & 434.10 & 430.52 & 433.72 & 420.77 &
57697700 \\
3 & 2021-07-06 & 433.78 & 434.01 & 430.01 & 432.93 & 420.00 &
68710400 \\
4 & 2021-07-07 & 433.66 & 434.76 & 431.51 & 434.46 & 421.49 &
63549500 \\
... & ... & ... & ... & ... & ... & ... & ... \\
17 & 2021-07-26 & 439.31 & 441.03 & 439.26 & 441.02 & 427.85 &
43719200 \\
18 & 2021-07-27 & 439.91 & 439.94 & 435.99 & 439.01 & 425.90 &
67397100 \\
19 & 2021-07-28 & 439.68 & 440.30 & 437.31 & 438.83 & 425.73 &
52472400 \\
20 & 2021-07-29 & 439.82 & 441.80 & 439.81 & 440.65 & 427.49 &
47435300 \\
21 & 2021-07-30 & 437.91 & 440.06 & 437.77 & 438.51 & 425.42 &
68951200 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Retrieve the first five rows of
\texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[:}\DecValTok{5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 &
64827900 \\
1 & 2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 &
53441000 \\
2 & 2021-07-02 & 431.67 & 434.10 & 430.52 & 433.72 & 420.77 &
57697700 \\
3 & 2021-07-06 & 433.78 & 434.01 & 430.01 & 432.93 & 420.00 &
68710400 \\
4 & 2021-07-07 & 433.66 & 434.76 & 431.51 & 434.46 & 421.49 &
63549500 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

There are a couple of row slicing tricks that involve negative numbers
that are worth mentioning.

The syntax \texttt{df{[}-n:{]}} retrieves the last \texttt{n} rows of
\texttt{df}. The following code retrieves the last five rows of
\texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\OperatorTok{{-}}\DecValTok{5}\NormalTok{:]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
17 & 2021-07-26 & 439.31 & 441.03 & 439.26 & 441.02 & 427.85 &
43719200 \\
18 & 2021-07-27 & 439.91 & 439.94 & 435.99 & 439.01 & 425.90 &
67397100 \\
19 & 2021-07-28 & 439.68 & 440.30 & 437.31 & 438.83 & 425.73 &
52472400 \\
20 & 2021-07-29 & 439.82 & 441.80 & 439.81 & 440.65 & 427.49 &
47435300 \\
21 & 2021-07-30 & 437.91 & 440.06 & 437.77 & 438.51 & 425.42 &
68951200 \\
\end{longtable}

The syntax \texttt{df{[}:-n{]}} retrieves all but the last \texttt{n}
rows of \texttt{df}. The following code retrieves all but the last 10
rows of \texttt{df\_spy}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[:}\OperatorTok{{-}}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 &
64827900 \\
1 & 2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 &
53441000 \\
2 & 2021-07-02 & 431.67 & 434.10 & 430.52 & 433.72 & 420.77 &
57697700 \\
3 & 2021-07-06 & 433.78 & 434.01 & 430.01 & 432.93 & 420.00 &
68710400 \\
4 & 2021-07-07 & 433.66 & 434.76 & 431.51 & 434.46 & 421.49 &
63549500 \\
... & ... & ... & ... & ... & ... & ... & ... \\
7 & 2021-07-12 & 435.43 & 437.35 & 434.97 & 437.08 & 424.03 &
52889600 \\
8 & 2021-07-13 & 436.24 & 437.84 & 435.31 & 435.59 & 422.58 &
52911300 \\
9 & 2021-07-14 & 437.40 & 437.92 & 434.91 & 436.24 & 423.21 &
64130400 \\
10 & 2021-07-15 & 434.81 & 435.53 & 432.72 & 434.75 & 421.77 &
55126400 \\
11 & 2021-07-16 & 436.01 & 436.06 & 430.92 & 431.34 & 418.46 &
75874700 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Retrieve the first row of \texttt{df\_spy} with
negative indexing.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[:}\OperatorTok{{-}}\NormalTok{(}\BuiltInTok{len}\NormalTok{(df\_spy)}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 &
64827900 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Use simple slicing to select the last three
rows of a \texttt{df\_spy}: 1) without explicitly using row numbers; 2)
with explicitly using row numbers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\BuiltInTok{len}\NormalTok{(df\_spy)}\OperatorTok{{-}}\DecValTok{3}\NormalTok{:}\BuiltInTok{len}\NormalTok{(df\_spy)]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
19 & 2021-07-28 & 439.68 & 440.30 & 437.31 & 438.83 & 425.73 &
52472400 \\
20 & 2021-07-29 & 439.82 & 441.80 & 439.81 & 440.65 & 427.49 &
47435300 \\
21 & 2021-07-30 & 437.91 & 440.06 & 437.77 & 438.51 & 425.42 &
68951200 \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[}\OperatorTok{{-}}\DecValTok{3}\NormalTok{:]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
19 & 2021-07-28 & 439.68 & 440.30 & 437.31 & 438.83 & 425.73 &
52472400 \\
20 & 2021-07-29 & 439.82 & 441.80 & 439.81 & 440.65 & 427.49 &
47435300 \\
21 & 2021-07-30 & 437.91 & 440.06 & 437.77 & 438.51 & 425.42 &
68951200 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{dataframe-indexes}{%
\section{\texorpdfstring{\texttt{DataFrame}
Indexes}{DataFrame Indexes}}\label{dataframe-indexes}}

Under the hood, a \texttt{DataFrame} has several \texttt{indexes}:

\texttt{columns} - the set of column names is an (explicit) index.

\texttt{row} - whenever a \texttt{DataFrame} is created, there is an
explicit row index that is created. If one isn't specified, then a
sequence of non-negative integers is used.

\texttt{implicit} - each row has an implicit row-number, and each column
has an implicit column-number.

Let's take a look at the \texttt{columns} index of \texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.columns}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Index(['date', 'open', 'high', 'low', 'close', 'adj_close', 'volume'], dtype='object')
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(df\_spy.columns)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pandas.core.indexes.base.Index
\end{verbatim}

Next, let's take a look at the explicit row \texttt{index} attribute of
\texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.index}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
RangeIndex(start=0, stop=22, step=1)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(df\_spy.index)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pandas.core.indexes.range.RangeIndex
\end{verbatim}

Since we reset the index for \texttt{df\_spy}, a \texttt{RangeIndex}
object is used for the explicit row \texttt{index}. You can think of a
\texttt{RangeIndex} object as a glorified set of consecutive integers.

For the most part, we won't be too concerned with \texttt{indexes}. A
lot of data analysis can be done without worrying about them. However,
it's good to be aware \texttt{indexes} exist becase they can come into
play for more advanced topics, such as joining tables together; they
also come up in Stack Overflow examples frequently.

For the purposes of this chapter, our interest in \texttt{indexes} comes
from how they are related to two built-in \texttt{DataFrame}
\emph{indexers}: \texttt{DataFrame.iloc} and \texttt{DataFrame.loc}.

\hypertarget{indexing-with-dataframe.iloc}{%
\section{\texorpdfstring{Indexing with
\texttt{DataFrame.iloc}}{Indexing with DataFrame.iloc}}\label{indexing-with-dataframe.iloc}}

The indexer \texttt{DataFrame.iloc} can be used to access rows and
columns using their implicit row and column numbers.

Here is an example of \texttt{iloc} that retrieves the first two rows of
\texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.iloc[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 &
64827900 \\
1 & 2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 &
53441000 \\
\end{longtable}

Notice, that because we didn't specify any column numbers, the code
above retrieves all columns.

The following code grabs the first three row and the first three columns
of \texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.iloc[}\DecValTok{0}\NormalTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{0}\NormalTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& date & open & high \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 \\
1 & 2021-07-01 & 428.87 & 430.60 \\
2 & 2021-07-02 & 431.67 & 434.10 \\
\end{longtable}

We can also supply \texttt{.iloc} with \texttt{lists} rather than ranges
to specify custom sets of columns and rows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst\_row }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{] }\CommentTok{\# 0th and 2nd row}
\NormalTok{lst\_col }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{6}\NormalTok{] }\CommentTok{\# date and adj\_close columns}
\NormalTok{df\_spy.iloc[lst\_row, lst\_col]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& date & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 64827900 \\
2 & 2021-07-02 & 57697700 \\
\end{longtable}

Using \texttt{lists} as a means of indexing is sometimes referred to as
\emph{fancy indexing}.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge} Use fancy indexing to grab the 14th, 0th, and
5th rows of \texttt{df\_spy} - in that order.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.iloc[[}\DecValTok{14}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
14 & 2021-07-21 & 432.34 & 434.70 & 431.01 & 434.55 & 421.57 &
64724400 \\
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 &
64827900 \\
5 & 2021-07-08 & 428.78 & 431.73 & 427.52 & 430.92 & 418.05 &
97595200 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{indexing-with-dataframe.loc}{%
\section{\texorpdfstring{Indexing with
\texttt{DataFrame.loc}}{Indexing with DataFrame.loc}}\label{indexing-with-dataframe.loc}}

Rather than using the implicit row or column numbers, it is often more
useful to access data by using the explicit row or column indices.

Let's use the \texttt{DataFrame.set\_index()} method to set the
\texttt{date} column as our new index. The \texttt{dates} will be a more
interesting explicit index.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.set\_index(}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllll@{}}
\toprule\noalign{}
& open & high & low & close & adj\_close & volume \\
date & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 & 64827900 \\
2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 & 53441000 \\
2021-07-02 & 431.67 & 434.10 & 430.52 & 433.72 & 420.77 & 57697700 \\
2021-07-06 & 433.78 & 434.01 & 430.01 & 432.93 & 420.00 & 68710400 \\
2021-07-07 & 433.66 & 434.76 & 431.51 & 434.46 & 421.49 & 63549500 \\
\end{longtable}

To see the effect of the above code, we can have a look at the
\texttt{index} of \texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.index}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
DatetimeIndex(['2021-06-30', '2021-07-01', '2021-07-02', '2021-07-06',
               '2021-07-07', '2021-07-08', '2021-07-09', '2021-07-12',
               '2021-07-13', '2021-07-14', '2021-07-15', '2021-07-16',
               '2021-07-19', '2021-07-20', '2021-07-21', '2021-07-22',
               '2021-07-23', '2021-07-26', '2021-07-27', '2021-07-28',
               '2021-07-29', '2021-07-30'],
              dtype='datetime64[ns]', name='date', freq=None)
\end{verbatim}

And notice that \texttt{date} is no longer column of \texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.columns}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Index(['open', 'high', 'low', 'close', 'adj_close', 'volume'], dtype='object')
\end{verbatim}

Now that we have successfully set the row \texttt{index} of
\texttt{df\_spy} to be the \texttt{date}, let's see how we can use this
\texttt{index} to access the data via \texttt{.loc}.

Here is an example of how we can grab a slice of rows, associated with a
date-range.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.loc[}\StringTok{\textquotesingle{}2021{-}07{-}23\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}2021{-}07{-}31\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllll@{}}
\toprule\noalign{}
& open & high & low & close & adj\_close & volume \\
date & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2021-07-23 & 437.52 & 440.30 & 436.79 & 439.94 & 426.80 & 63766600 \\
2021-07-26 & 439.31 & 441.03 & 439.26 & 441.02 & 427.85 & 43719200 \\
2021-07-27 & 439.91 & 439.94 & 435.99 & 439.01 & 425.90 & 67397100 \\
2021-07-28 & 439.68 & 440.30 & 437.31 & 438.83 & 425.73 & 52472400 \\
2021-07-29 & 439.82 & 441.80 & 439.81 & 440.65 & 427.49 & 47435300 \\
2021-07-30 & 437.91 & 440.06 & 437.77 & 438.51 & 425.42 & 68951200 \\
\end{longtable}

If we want to select only the \texttt{volume} and \texttt{adjusted}
columns for these dates, we would type the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.loc[}\StringTok{\textquotesingle{}2021{-}07{-}23\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}2021{-}07{-}31\textquotesingle{}}\NormalTok{, [}\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& volume & adj\_close \\
date & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2021-07-23 & 63766600 & 426.80 \\
2021-07-26 & 43719200 & 427.85 \\
2021-07-27 & 67397100 & 425.90 \\
2021-07-28 & 52472400 & 425.73 \\
2021-07-29 & 47435300 & 427.49 \\
2021-07-30 & 68951200 & 425.42 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Use \texttt{.loc} to grab the \texttt{date},
\texttt{volume}, and \texttt{close} columns from \texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.loc[:,[}\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& volume & close \\
date & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2021-06-30 & 64827900 & 428.06 \\
2021-07-01 & 53441000 & 430.43 \\
2021-07-02 & 57697700 & 433.72 \\
2021-07-06 & 68710400 & 432.93 \\
2021-07-07 & 63549500 & 434.46 \\
... & ... & ... \\
2021-07-26 & 43719200 & 441.02 \\
2021-07-27 & 67397100 & 439.01 \\
2021-07-28 & 52472400 & 438.83 \\
2021-07-29 & 47435300 & 440.65 \\
2021-07-30 & 68951200 & 438.51 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{related-reading-1}{%
\section{Related Reading}\label{related-reading-1}}

\emph{Python Data Science Handbook} - Section 2.7 - Fancy Indexing

\emph{Python Data Science Handbook} - Section 3.2 - Data Indexing and
Selection

\bookmarksetup{startatroot}

\hypertarget{dataframe-querying}{%
\chapter{\texorpdfstring{\texttt{DataFrame}
Querying}{DataFrame Querying}}\label{dataframe-querying}}

In the previous chapter we discussed accessing rows of a
\texttt{DataFrame} by row position. In practice, I don't find this
particularly useful. Rather, I find that I usually access rows by some
kind of logical condition, which is referred to as \emph{querying} the
\texttt{DataFrame}.

In this chapter we discuss two ways of querying a \texttt{DataFrame}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  masking
\item
  the \texttt{DataFrame.query()} method.
\end{enumerate}

\hypertarget{importing-packages-3}{%
\section{Importing Packages}\label{importing-packages-3}}

Let's first import the packages that we will need.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ yfinance }\ImportTok{as}\NormalTok{ yf}
\NormalTok{yf.pdr\_override()}
\ImportTok{from}\NormalTok{ pandas\_datareader }\ImportTok{import}\NormalTok{ data }\ImportTok{as}\NormalTok{ pdr}
\NormalTok{pd.set\_option(}\StringTok{\textquotesingle{}display.max\_rows\textquotesingle{}}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{reading-in-data-2}{%
\section{Reading-In Data}\label{reading-in-data-2}}

Next, let's use \texttt{pandas\_datareader} to read-in some \texttt{SPY}
data from July 2021.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy }\OperatorTok{=}\NormalTok{ pdr.get\_data\_yahoo(}\StringTok{\textquotesingle{}SPY\textquotesingle{}}\NormalTok{, start}\OperatorTok{=}\StringTok{\textquotesingle{}2021{-}06{-}30\textquotesingle{}}\NormalTok{, end}\OperatorTok{=}\StringTok{\textquotesingle{}2021{-}07{-}31\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_spy }\OperatorTok{=}\NormalTok{ df\_spy.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[*********************100%***********************]  1 of 1 completed
\end{verbatim}

\begin{longtable}[]{@{}lllllll@{}}
\toprule\noalign{}
& Open & High & Low & Close & Adj Close & Volume \\
Date & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 & 64827900 \\
2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 & 53441000 \\
2021-07-02 & 431.67 & 434.10 & 430.52 & 433.72 & 420.77 & 57697700 \\
2021-07-06 & 433.78 & 434.01 & 430.01 & 432.93 & 420.00 & 68710400 \\
2021-07-07 & 433.66 & 434.76 & 431.51 & 434.46 & 421.49 & 63549500 \\
\end{longtable}

The following code resets the \texttt{index} so that \texttt{Date} is a
regular column, and then makes the all columns names snake-case.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.reset\_index(inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{df\_spy.columns }\OperatorTok{=}\NormalTok{ df\_spy.columns.}\BuiltInTok{str}\NormalTok{.lower().}\BuiltInTok{str}\NormalTok{.replace(}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\_\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_spy.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 &
64827900 \\
1 & 2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 &
53441000 \\
2 & 2021-07-02 & 431.67 & 434.10 & 430.52 & 433.72 & 420.77 &
57697700 \\
3 & 2021-07-06 & 433.78 & 434.01 & 430.01 & 432.93 & 420.00 &
68710400 \\
4 & 2021-07-07 & 433.66 & 434.76 & 431.51 & 434.46 & 421.49 &
63549500 \\
\end{longtable}

\hypertarget{comparison-and-dataframe-columns}{%
\section{\texorpdfstring{Comparison and \texttt{DataFrame}
Columns}{Comparison and DataFrame Columns}}\label{comparison-and-dataframe-columns}}

As discussed in a previous chapter, a column of a \texttt{DataFrame} is
a \texttt{Series} object, which is a souped up \texttt{numpy.array}
(think vector or matrix).

Let's separate out the \texttt{adjusted} column of \texttt{df\_spy} and
assign it to a variable.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.options.display.max\_rows }\OperatorTok{=} \DecValTok{6} \CommentTok{\# this modifies the printing of dataframes}
\NormalTok{ser\_adjusted }\OperatorTok{=}\NormalTok{ df\_spy[}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{]}
\NormalTok{ser\_adjusted}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0     415.28
1     417.58
2     420.77
       ...  
19    425.73
20    427.49
21    425.42
Name: adj_close, Length: 22, dtype: float64
\end{verbatim}

Recall that a \texttt{pandas.Series} is smart with respect to
component-wise arithmetic operations, meaning it behaves like a vector
from linear algebra. This means that arithmetic operations are
\emph{broadcasted} as you might expect.

For example, division by 100 is broadcasted component-wise.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ser\_adjusted }\OperatorTok{/} \DecValTok{100}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0     4.1528
1     4.1758
2     4.2077
       ...  
19    4.2573
20    4.2749
21    4.2542
Name: adj_close, Length: 22, dtype: float64
\end{verbatim}

It is a convenient fact that this broadcasting behavior also occurs with
comparison, and produces a \texttt{Series} of booleans.

The following code checks which elements of \texttt{ser\_adjusted} are
greater than 425.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ser\_test }\OperatorTok{=}\NormalTok{ (ser\_adjusted }\OperatorTok{\textgreater{}} \DecValTok{425}\NormalTok{)}
\NormalTok{ser\_test}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0     False
1     False
2     False
      ...  
19     True
20     True
21     True
Name: adj_close, Length: 22, dtype: bool
\end{verbatim}

Let's check that the resulting variable \texttt{ser\_test} is a
\texttt{pandas.Series}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(ser\_test)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pandas.core.series.Series
\end{verbatim}

And finally let's observe the \texttt{.values} elements of
\texttt{ser\_test}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(ser\_test.values)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[False False False False False False False False False False False False
 False False False False  True  True  True  True  True  True]
\end{verbatim}

A few observation about what just happened:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  When we compare a \texttt{Series} of numerical values
  (\texttt{ser\_adjusted}) to a single number (\texttt{425}), we get
  back a \texttt{Series} of booleans (\texttt{ser\_test}).
\item
  We have that \texttt{ser\_test{[}i{]}} =
  (\texttt{ser\_adjusted{[}i{]}\ \textgreater{}\ 425}).
\item
  So the comparison operation was broadcasted as advertised.
\end{enumerate}

This is easy to see by appending \texttt{ser\_test} to \texttt{df\_spy}
and then reprinting.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.options.display.max\_rows }\OperatorTok{=} \DecValTok{25}
\NormalTok{df\_spy[}\StringTok{\textquotesingle{}test\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ ser\_test}
\NormalTok{df\_spy}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume & test \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 & 64827900 &
False \\
1 & 2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 & 53441000 &
False \\
2 & 2021-07-02 & 431.67 & 434.10 & 430.52 & 433.72 & 420.77 & 57697700 &
False \\
3 & 2021-07-06 & 433.78 & 434.01 & 430.01 & 432.93 & 420.00 & 68710400 &
False \\
4 & 2021-07-07 & 433.66 & 434.76 & 431.51 & 434.46 & 421.49 & 63549500 &
False \\
5 & 2021-07-08 & 428.78 & 431.73 & 427.52 & 430.92 & 418.05 & 97595200 &
False \\
6 & 2021-07-09 & 432.53 & 435.84 & 430.71 & 435.52 & 422.51 & 76238600 &
False \\
7 & 2021-07-12 & 435.43 & 437.35 & 434.97 & 437.08 & 424.03 & 52889600 &
False \\
8 & 2021-07-13 & 436.24 & 437.84 & 435.31 & 435.59 & 422.58 & 52911300 &
False \\
9 & 2021-07-14 & 437.40 & 437.92 & 434.91 & 436.24 & 423.21 & 64130400 &
False \\
10 & 2021-07-15 & 434.81 & 435.53 & 432.72 & 434.75 & 421.77 & 55126400
& False \\
11 & 2021-07-16 & 436.01 & 436.06 & 430.92 & 431.34 & 418.46 & 75874700
& False \\
12 & 2021-07-19 & 426.19 & 431.41 & 421.97 & 424.97 & 412.28 & 147987000
& False \\
13 & 2021-07-20 & 425.68 & 432.42 & 424.83 & 431.06 & 418.19 & 99608200
& False \\
14 & 2021-07-21 & 432.34 & 434.70 & 431.01 & 434.55 & 421.57 & 64724400
& False \\
15 & 2021-07-22 & 434.74 & 435.72 & 433.69 & 435.46 & 422.46 & 47878500
& False \\
16 & 2021-07-23 & 437.52 & 440.30 & 436.79 & 439.94 & 426.80 & 63766600
& True \\
17 & 2021-07-26 & 439.31 & 441.03 & 439.26 & 441.02 & 427.85 & 43719200
& True \\
18 & 2021-07-27 & 439.91 & 439.94 & 435.99 & 439.01 & 425.90 & 67397100
& True \\
19 & 2021-07-28 & 439.68 & 440.30 & 437.31 & 438.83 & 425.73 & 52472400
& True \\
20 & 2021-07-29 & 439.82 & 441.80 & 439.81 & 440.65 & 427.49 & 47435300
& True \\
21 & 2021-07-30 & 437.91 & 440.06 & 437.77 & 438.51 & 425.42 & 68951200
& True \\
\end{longtable}

As we will see in the next two sections, the broadcasting of comparison
can be used to query subsets of rows of a \texttt{DataFrame}.

\hypertarget{dataframe-masking}{%
\section{\texorpdfstring{\texttt{DataFrame}
Masking}{DataFrame Masking}}\label{dataframe-masking}}

From the code below we know that \texttt{df\_spy} has 22 rows.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy.shape}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(22, 8)
\end{verbatim}

The following code creates a list consisting of 22 booleans, all of them
\texttt{False}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst\_bool }\OperatorTok{=}\NormalTok{ [}\VariableTok{False}\NormalTok{] }\OperatorTok{*} \DecValTok{22}
\NormalTok{lst\_bool}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False,
 False]
\end{verbatim}

Now, let's see what happens when we feed this \texttt{list} of
\texttt{False} booleans into \texttt{df\_spy} using square brackets.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[lst\_bool]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume & test \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Verify that \texttt{df\_spy{[}lst\_bool{]}} is
an empty \texttt{DataFrame}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(df\_spy[lst\_bool])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pandas.core.frame.DataFrame
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_spy[lst\_bool].shape}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(0, 8)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Next, let's modify \texttt{lst\_bool} slightly by changing the 0th entry
to \texttt{True}. Then lets feed \texttt{lst\_bool} into
\texttt{df\_spy} again.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst\_bool[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \VariableTok{True}
\NormalTok{df\_spy[lst\_bool]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume & test \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 & 64827900 &
False \\
\end{longtable}

So what happened? Notice that \texttt{df\_spy{[}lst\_bool{]}} returns a
\texttt{DataFrame} consisting only of the 0th row of \texttt{df\_spy}.

Let's modify \texttt{lst\_bool} once again, by setting the 1st entry of
\texttt{df\_spy} to \texttt{True}, and then once again feed it into
\texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst\_bool[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \VariableTok{True}
\NormalTok{df\_spy[lst\_bool]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume & test \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 & 64827900 &
False \\
1 & 2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 & 53441000 &
False \\
\end{longtable}

\textbf{Punchline:} What is returned by the code
\texttt{df\_spy{[}lst\_bool{]}} will be a \texttt{DataFrame} consisting
of all the rows corresponding to the \texttt{True} entries of
\texttt{lst\_bool}.

This is called \texttt{DataFrame} \emph{masking}.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Modify \texttt{lst\_bool} and then use
\texttt{DataFrame} masking to grab the 0th, 1st and, 3rd rows of
\texttt{df\_spy}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst\_bool[}\DecValTok{3}\NormalTok{] }\OperatorTok{=} \VariableTok{True}
\NormalTok{df\_spy[lst\_bool]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & open & high & low & close & adj\_close & volume & test \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & 427.21 & 428.78 & 427.18 & 428.06 & 415.28 & 64827900 &
False \\
1 & 2021-07-01 & 428.87 & 430.60 & 428.80 & 430.43 & 417.58 & 53441000 &
False \\
3 & 2021-07-06 & 433.78 & 434.01 & 430.01 & 432.93 & 420.00 & 68710400 &
False \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{querying-with-dataframe-masking}{%
\section{\texorpdfstring{Querying with \texttt{DataFrame}
Masking}{Querying with DataFrame Masking}}\label{querying-with-dataframe-masking}}

We often want to query a \texttt{DataFrame} based on some kind of
comparison involving its column values.

We can achieve this kind of querying by combining the broadcasting of
comparison over \texttt{DataFrame} columns with \texttt{DataFrame}
masking.

In order to consider concrete examples, let's read-in some data.

The following code reads in a data set consisting of end-of-day prices
for four different ETFs (SPY, IWM, QQQ, DIA), during the month of July
2021.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.options.display.max\_rows }\OperatorTok{=} \DecValTok{25}
\NormalTok{df\_etf }\OperatorTok{=}\NormalTok{ pdr.get\_data\_yahoo([}\StringTok{\textquotesingle{}SPY\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}QQQ\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}IWM\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}DIA\textquotesingle{}}\NormalTok{], start}\OperatorTok{=}\StringTok{\textquotesingle{}2021{-}06{-}30\textquotesingle{}}\NormalTok{, end}\OperatorTok{=}\StringTok{\textquotesingle{}2021{-}07{-}31\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_etf }\OperatorTok{=}\NormalTok{ df\_etf.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{df\_etf.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[*********************100%***********************]  4 of 4 completed
\end{verbatim}

\begin{longtable}[]{@{}llllllllllllllllllllll@{}}
\toprule\noalign{}
&
\multicolumn{4}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 6\tabcolsep}}{%
Adj Close} &
\multicolumn{4}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 6\tabcolsep}}{%
Close} &
\multicolumn{2}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 2\tabcolsep}}{%
High} & ... &
\multicolumn{2}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 2\tabcolsep}}{%
Low} &
\multicolumn{4}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 6\tabcolsep}}{%
Open} &
\multicolumn{4}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 6\tabcolsep}@{}}{%
Volume} \\
& DIA & IWM & QQQ & SPY & DIA & IWM & QQQ & SPY & DIA & IWM & ... & QQQ
& SPY & DIA & IWM & QQQ & SPY & DIA & IWM & QQQ & SPY \\
Date & & & & & & & & & & & & & & & & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2021-06-30 & 331.30 & 223.29 & 349.98 & 415.28 & 344.95 & 229.37 &
354.43 & 428.06 & 345.51 & 230.32 & ... & 353.83 & 427.18 & 342.38 &
228.65 & 354.83 & 427.21 & 3778900 & 26039000 & 32724000 & 64827900 \\
2021-07-01 & 332.66 & 225.26 & 350.11 & 417.58 & 346.36 & 231.39 &
354.57 & 430.43 & 346.40 & 231.85 & ... & 352.68 & 428.80 & 345.78 &
230.81 & 354.07 & 428.87 & 3606900 & 18089100 & 29290000 & 53441000 \\
2021-07-02 & 334.17 & 223.11 & 354.13 & 420.77 & 347.94 & 229.19 &
358.64 & 433.72 & 348.29 & 232.08 & ... & 356.28 & 430.52 & 347.04 &
232.00 & 356.52 & 431.67 & 3013500 & 21029700 & 32727200 & 57697700 \\
2021-07-06 & 332.14 & 219.87 & 355.66 & 420.00 & 345.82 & 225.86 &
360.19 & 432.93 & 348.11 & 229.46 & ... & 356.49 & 430.01 & 347.75 &
229.36 & 359.26 & 433.78 & 3910600 & 27771300 & 38842400 & 68710400 \\
2021-07-07 & 333.20 & 217.83 & 356.41 & 421.49 & 346.92 & 223.76 &
360.95 & 434.46 & 347.14 & 226.67 & ... & 358.94 & 431.51 & 345.65 &
225.54 & 362.45 & 433.66 & 3347000 & 28521500 & 35265200 & 63549500 \\
\end{longtable}

This data is not as tidy as we would like. Let's use method chaining to
perform a series of data munging operations.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    (}
\NormalTok{    df\_etf}
\NormalTok{        .stack() }\CommentTok{\#pivot the table}
\NormalTok{        .reset\_index() }\CommentTok{\#turn date into a column}
\NormalTok{        .rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}level\_1\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}Symbols\textquotesingle{}}\NormalTok{\}) }\CommentTok{\#renaming a column}
\NormalTok{        .sort\_values(by}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}Symbols\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{]) }\CommentTok{\#sort}
\NormalTok{        .rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Symbols\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Adj Close\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}Close\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{, }
                         \StringTok{\textquotesingle{}High\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Low\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Open\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Volume\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{\}) }\CommentTok{\#renaming columns}
\NormalTok{        [[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{]] }\CommentTok{\#reordering columns}
\NormalTok{        .reset\_index(drop}\OperatorTok{=}\VariableTok{True}\NormalTok{)    }
\NormalTok{    )}
\NormalTok{df\_etf}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & DIA & 342.38 & 345.51 & 342.35 & 344.95 & 3778900 &
331.30 \\
1 & 2021-07-01 & DIA & 345.78 & 346.40 & 344.92 & 346.36 & 3606900 &
332.66 \\
2 & 2021-07-02 & DIA & 347.04 & 348.29 & 346.18 & 347.94 & 3013500 &
334.17 \\
3 & 2021-07-06 & DIA & 347.75 & 348.11 & 343.60 & 345.82 & 3910600 &
332.14 \\
4 & 2021-07-07 & DIA & 345.65 & 347.14 & 344.43 & 346.92 & 3347000 &
333.20 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
83 & 2021-07-26 & SPY & 439.31 & 441.03 & 439.26 & 441.02 & 43719200 &
427.85 \\
84 & 2021-07-27 & SPY & 439.91 & 439.94 & 435.99 & 439.01 & 67397100 &
425.90 \\
85 & 2021-07-28 & SPY & 439.68 & 440.30 & 437.31 & 438.83 & 52472400 &
425.73 \\
86 & 2021-07-29 & SPY & 439.82 & 441.80 & 439.81 & 440.65 & 47435300 &
427.49 \\
87 & 2021-07-30 & SPY & 437.91 & 440.06 & 437.77 & 438.51 & 68951200 &
425.42 \\
\end{longtable}

\hypertarget{querying-for-one-symbol}{%
\subsection{Querying for One Symbol}\label{querying-for-one-symbol}}

We are now ready to apply \texttt{DataFrame} masking to our ETF data
set.

As a first example, let's isolate all the rows of \texttt{df\_etf} that
correspond to \texttt{IWM}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.options.display.max\_rows }\OperatorTok{=} \DecValTok{6}
\NormalTok{ser\_bool }\OperatorTok{=}\NormalTok{ (df\_etf[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \StringTok{"IWM"}\NormalTok{)}
\NormalTok{df\_etf[ser\_bool]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
22 & 2021-06-30 & IWM & 228.65 & 230.32 & 227.76 & 229.37 & 26039000 &
223.29 \\
23 & 2021-07-01 & IWM & 230.81 & 231.85 & 229.71 & 231.39 & 18089100 &
225.26 \\
24 & 2021-07-02 & IWM & 232.00 & 232.08 & 228.56 & 229.19 & 21029700 &
223.11 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
41 & 2021-07-28 & IWM & 219.00 & 222.59 & 217.40 & 220.82 & 33043700 &
214.97 \\
42 & 2021-07-29 & IWM & 222.79 & 224.44 & 222.14 & 222.52 & 22634800 &
216.62 \\
43 & 2021-07-30 & IWM & 221.65 & 224.05 & 220.28 & 221.05 & 28473000 &
215.19 \\
\end{longtable}

Notice that we did this in two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Calculate the series of \texttt{booleans} called \texttt{ser\_bool}
  using comparison broadcasting.
\item
  Perform the masking by using square brackets \texttt{{[}{]}} and
  \texttt{ser\_bool}.
\end{enumerate}

We can actually perform this masking in a single line of code, without
creating the intermediate variable \texttt{ser\_bool}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf[df\_etf[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \StringTok{"IWM"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
22 & 2021-06-30 & IWM & 228.65 & 230.32 & 227.76 & 229.37 & 26039000 &
223.29 \\
23 & 2021-07-01 & IWM & 230.81 & 231.85 & 229.71 & 231.39 & 18089100 &
225.26 \\
24 & 2021-07-02 & IWM & 232.00 & 232.08 & 228.56 & 229.19 & 21029700 &
223.11 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
41 & 2021-07-28 & IWM & 219.00 & 222.59 & 217.40 & 220.82 & 33043700 &
214.97 \\
42 & 2021-07-29 & IWM & 222.79 & 224.44 & 222.14 & 222.52 & 22634800 &
216.62 \\
43 & 2021-07-30 & IWM & 221.65 & 224.05 & 220.28 & 221.05 & 28473000 &
215.19 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Select all the rows of \texttt{df\_etf} for
\texttt{QQQ}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf[df\_etf[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \StringTok{\textquotesingle{}QQQ\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
44 & 2021-06-30 & QQQ & 354.83 & 355.23 & 353.83 & 354.43 & 32724000 &
349.98 \\
45 & 2021-07-01 & QQQ & 354.07 & 355.09 & 352.68 & 354.57 & 29290000 &
350.11 \\
46 & 2021-07-02 & QQQ & 356.52 & 358.97 & 356.28 & 358.64 & 32727200 &
354.13 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
63 & 2021-07-28 & QQQ & 365.60 & 367.45 & 363.24 & 365.83 & 42066200 &
361.23 \\
64 & 2021-07-29 & QQQ & 365.25 & 367.68 & 365.25 & 366.48 & 25672500 &
361.88 \\
65 & 2021-07-30 & QQQ & 362.44 & 365.17 & 362.41 & 364.57 & 36484600 &
359.99 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{querying-for-multiple-symbols}{%
\subsection{Querying for Multiple
Symbols}\label{querying-for-multiple-symbols}}

We can use the \texttt{.isin()} method to query a \texttt{DataFrame} for
multiple symbols. The technique is to feed \texttt{.isin()} a
\texttt{list} of symbols you want to query for.

The following code grabs all the rows of \texttt{df\_etf} for both
\texttt{QQQ} and \texttt{DIA}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf[df\_etf[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{].isin([}\StringTok{\textquotesingle{}QQQ\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}DIA\textquotesingle{}}\NormalTok{])]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & DIA & 342.38 & 345.51 & 342.35 & 344.95 & 3778900 &
331.30 \\
1 & 2021-07-01 & DIA & 345.78 & 346.40 & 344.92 & 346.36 & 3606900 &
332.66 \\
2 & 2021-07-02 & DIA & 347.04 & 348.29 & 346.18 & 347.94 & 3013500 &
334.17 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
63 & 2021-07-28 & QQQ & 365.60 & 367.45 & 363.24 & 365.83 & 42066200 &
361.23 \\
64 & 2021-07-29 & QQQ & 365.25 & 367.68 & 365.25 & 366.48 & 25672500 &
361.88 \\
65 & 2021-07-30 & QQQ & 362.44 & 365.17 & 362.41 & 364.57 & 36484600 &
359.99 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Grab all rows of \texttt{df\_etf} corresponding
to \texttt{SPY}, \texttt{IWM}, and \texttt{QQQ}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf[df\_etf[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{].isin([}\StringTok{\textquotesingle{}SPY\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}IWM\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}QQQ\textquotesingle{}}\NormalTok{])]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
22 & 2021-06-30 & IWM & 228.65 & 230.32 & 227.76 & 229.37 & 26039000 &
223.29 \\
23 & 2021-07-01 & IWM & 230.81 & 231.85 & 229.71 & 231.39 & 18089100 &
225.26 \\
24 & 2021-07-02 & IWM & 232.00 & 232.08 & 228.56 & 229.19 & 21029700 &
223.11 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
85 & 2021-07-28 & SPY & 439.68 & 440.30 & 437.31 & 438.83 & 52472400 &
425.73 \\
86 & 2021-07-29 & SPY & 439.82 & 441.80 & 439.81 & 440.65 & 47435300 &
427.49 \\
87 & 2021-07-30 & SPY & 437.91 & 440.06 & 437.77 & 438.51 & 68951200 &
425.42 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{querying-for-dates}{%
\subsection{Querying for Dates}\label{querying-for-dates}}

The following code grabs all the rows of \texttt{df\_etf} that come
after the middle of the month.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf[df\_etf[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{] }\OperatorTok{\textgreater{}} \StringTok{\textquotesingle{}2021{-}07{-}15\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
11 & 2021-07-16 & DIA & 350.72 & 350.74 & 346.34 & 346.74 & 5710400 &
333.22 \\
12 & 2021-07-19 & DIA & 341.79 & 350.03 & 337.38 & 339.88 & 9715300 &
326.63 \\
13 & 2021-07-20 & DIA & 340.29 & 346.12 & 339.75 & 345.08 & 5802200 &
331.62 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
85 & 2021-07-28 & SPY & 439.68 & 440.30 & 437.31 & 438.83 & 52472400 &
425.73 \\
86 & 2021-07-29 & SPY & 439.82 & 441.80 & 439.81 & 440.65 & 47435300 &
427.49 \\
87 & 2021-07-30 & SPY & 437.91 & 440.06 & 437.77 & 438.51 & 68951200 &
425.42 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Grab all the rows of \texttt{df\_etf} for the
last trade date of the month.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf[df\_etf[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \StringTok{\textquotesingle{}2021{-}07{-}30\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
21 & 2021-07-30 & DIA & 349.88 & 351.01 & 348.67 & 349.48 & 3576700 &
335.85 \\
43 & 2021-07-30 & IWM & 221.65 & 224.05 & 220.28 & 221.05 & 28473000 &
215.19 \\
65 & 2021-07-30 & QQQ & 362.44 & 365.17 & 362.41 & 364.57 & 36484600 &
359.99 \\
87 & 2021-07-30 & SPY & 437.91 & 440.06 & 437.77 & 438.51 & 68951200 &
425.42 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{querying-on-multiple-criteria}{%
\subsection{Querying on Multiple
Criteria}\label{querying-on-multiple-criteria}}

We can filter on muliple criteria by using the \texttt{\&} operator,
which is the vectorized version of \texttt{and}.

Suppose that we want all rows for \texttt{SPY} that come before July
fourth.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bln\_ticker }\OperatorTok{=}\NormalTok{ (df\_etf[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \StringTok{\textquotesingle{}SPY\textquotesingle{}}\NormalTok{)}
\NormalTok{bln\_date }\OperatorTok{=}\NormalTok{ (df\_etf[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{] }\OperatorTok{\textless{}} \StringTok{\textquotesingle{}2021{-}07{-}04\textquotesingle{}}\NormalTok{)}
\NormalTok{bln\_combined }\OperatorTok{=}\NormalTok{ bln\_ticker }\OperatorTok{\&}\NormalTok{ bln\_date}

\NormalTok{df\_etf[bln\_combined]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
66 & 2021-06-30 & SPY & 427.21 & 428.78 & 427.18 & 428.06 & 64827900 &
415.28 \\
67 & 2021-07-01 & SPY & 428.87 & 430.60 & 428.80 & 430.43 & 53441000 &
417.58 \\
68 & 2021-07-02 & SPY & 431.67 & 434.10 & 430.52 & 433.72 & 57697700 &
420.77 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Isolate the rows for \texttt{QQQ} and
\texttt{IWM} on the last trading day before July 4th - try to not use
intermediate variables.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf[(df\_etf[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{].isin([}\StringTok{"QQQ"}\NormalTok{, }\StringTok{"IWM"}\NormalTok{])) }\OperatorTok{\&}\NormalTok{ (df\_etf[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{]}\OperatorTok{==}\StringTok{\textquotesingle{}2021{-}07{-}02\textquotesingle{}}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
24 & 2021-07-02 & IWM & 232.00 & 232.08 & 228.56 & 229.19 & 21029700 &
223.11 \\
46 & 2021-07-02 & QQQ & 356.52 & 358.97 & 356.28 & 358.64 & 32727200 &
354.13 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{querying-with-.query}{%
\section{\texorpdfstring{Querying with
\texttt{.query()}}{Querying with .query()}}\label{querying-with-.query}}

I find querying a \texttt{DataFrame} via masking to be rather
cumbersome.

I greatly prefer the use of the \texttt{DataFrame.query()} method which
uses SQL-like strings to define queries.

For example, the following code grabs all the rows corresponding to
\texttt{IWM}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf.query(}\StringTok{\textquotesingle{}symbol == "IWM"\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
22 & 2021-06-30 & IWM & 228.65 & 230.32 & 227.76 & 229.37 & 26039000 &
223.29 \\
23 & 2021-07-01 & IWM & 230.81 & 231.85 & 229.71 & 231.39 & 18089100 &
225.26 \\
24 & 2021-07-02 & IWM & 232.00 & 232.08 & 228.56 & 229.19 & 21029700 &
223.11 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
41 & 2021-07-28 & IWM & 219.00 & 222.59 & 217.40 & 220.82 & 33043700 &
214.97 \\
42 & 2021-07-29 & IWM & 222.79 & 224.44 & 222.14 & 222.52 & 22634800 &
216.62 \\
43 & 2021-07-30 & IWM & 221.65 & 224.05 & 220.28 & 221.05 & 28473000 &
215.19 \\
\end{longtable}

This code queries all rows corresponding to \texttt{QQQ} and
\texttt{DIA}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf.query(}\StringTok{\textquotesingle{}symbol in ("QQQ", "DIA")\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & DIA & 342.38 & 345.51 & 342.35 & 344.95 & 3778900 &
331.30 \\
1 & 2021-07-01 & DIA & 345.78 & 346.40 & 344.92 & 346.36 & 3606900 &
332.66 \\
2 & 2021-07-02 & DIA & 347.04 & 348.29 & 346.18 & 347.94 & 3013500 &
334.17 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
63 & 2021-07-28 & QQQ & 365.60 & 367.45 & 363.24 & 365.83 & 42066200 &
361.23 \\
64 & 2021-07-29 & QQQ & 365.25 & 367.68 & 365.25 & 366.48 & 25672500 &
361.88 \\
65 & 2021-07-30 & QQQ & 362.44 & 365.17 & 362.41 & 364.57 & 36484600 &
359.99 \\
\end{longtable}

Here we grab the rows corresponding to the first half of July.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf.query(}\StringTok{\textquotesingle{}date \textless{} "2021{-}07{-}15"\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & DIA & 342.38 & 345.51 & 342.35 & 344.95 & 3778900 &
331.30 \\
1 & 2021-07-01 & DIA & 345.78 & 346.40 & 344.92 & 346.36 & 3606900 &
332.66 \\
2 & 2021-07-02 & DIA & 347.04 & 348.29 & 346.18 & 347.94 & 3013500 &
334.17 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
73 & 2021-07-12 & SPY & 435.43 & 437.35 & 434.97 & 437.08 & 52889600 &
424.03 \\
74 & 2021-07-13 & SPY & 436.24 & 437.84 & 435.31 & 435.59 & 52911300 &
422.58 \\
75 & 2021-07-14 & SPY & 437.40 & 437.92 & 434.91 & 436.24 & 64130400 &
423.21 \\
\end{longtable}

And we can filter on multiple criteria via method chaining. Here we grab
all the rows for \texttt{SPY} and \texttt{IWM} from the second half of
the month.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}
\NormalTok{df\_etf}
\NormalTok{    .query(}\StringTok{\textquotesingle{}symbol in ("SPY", "IWM")\textquotesingle{}}\NormalTok{)}
\NormalTok{    .query(}\StringTok{\textquotesingle{}date \textgreater{} "2021{-}07{-}15"\textquotesingle{}}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
33 & 2021-07-16 & IWM & 219.83 & 219.88 & 214.47 & 214.95 & 36620200 &
209.25 \\
34 & 2021-07-19 & IWM & 210.63 & 214.45 & 209.05 & 211.73 & 58571000 &
206.12 \\
35 & 2021-07-20 & IWM & 212.20 & 219.27 & 211.26 & 218.30 & 40794600 &
212.51 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
85 & 2021-07-28 & SPY & 439.68 & 440.30 & 437.31 & 438.83 & 52472400 &
425.73 \\
86 & 2021-07-29 & SPY & 439.82 & 441.80 & 439.81 & 440.65 & 47435300 &
427.49 \\
87 & 2021-07-30 & SPY & 437.91 & 440.06 & 437.77 & 438.51 & 68951200 &
425.42 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Grab all the rows of \texttt{df\_etf} that
correspond to the following criteria: 1. \texttt{SPY} 2. first half of
month 3. close less than 435

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}
\NormalTok{df\_etf}
\NormalTok{    .query(}\StringTok{\textquotesingle{}symbol == "SPY"\textquotesingle{}}\NormalTok{)}
\NormalTok{    .query(}\StringTok{\textquotesingle{}date \textless{} "2021{-}07{-}15"\textquotesingle{}}\NormalTok{)}
\NormalTok{    .query(}\StringTok{\textquotesingle{}close \textless{} 435\textquotesingle{}}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
66 & 2021-06-30 & SPY & 427.21 & 428.78 & 427.18 & 428.06 & 64827900 &
415.28 \\
67 & 2021-07-01 & SPY & 428.87 & 430.60 & 428.80 & 430.43 & 53441000 &
417.58 \\
68 & 2021-07-02 & SPY & 431.67 & 434.10 & 430.52 & 433.72 & 57697700 &
420.77 \\
69 & 2021-07-06 & SPY & 433.78 & 434.01 & 430.01 & 432.93 & 68710400 &
420.00 \\
70 & 2021-07-07 & SPY & 433.66 & 434.76 & 431.51 & 434.46 & 63549500 &
421.49 \\
71 & 2021-07-08 & SPY & 428.78 & 431.73 & 427.52 & 430.92 & 97595200 &
418.05 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{related-reading-2}{%
\section{Related Reading}\label{related-reading-2}}

\emph{Python Data Science Handbook} - Section 2.6 - Comparisons, Masks,
and Boolean Logic

\emph{Python Data Science Handbook} - Section 2.7 - Fancy Indexing

\emph{Python Data Science Handbook} - Section 3.2 - Data Indexing and
Selection

\emph{Python Data Science Handbook} - Section 3.12 - High Performance
Pandas

\bookmarksetup{startatroot}

\hypertarget{functions-and-the-dataframe.apply-method}{%
\chapter{\texorpdfstring{Functions and the \texttt{DataFrame.apply()}
Method}{Functions and the DataFrame.apply() Method}}\label{functions-and-the-dataframe.apply-method}}

We have already discussed how to add a new column to a
\texttt{DataFrame} that is a simple function of existing columns.

Suppose the situation is a little more complicated, and that the column
we want to add is some kind of custom (user defined) function of
existing columns.

In this tutorial we discuss two ways of doing this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  A \texttt{for} loop
\item
  \texttt{DataFrame.apply()}
\end{enumerate}

We will use a finance task to motivate these two techniques: calculating
the payoffs of expiring options.

\hypertarget{defining-functions}{%
\section{Defining Functions}\label{defining-functions}}

Defining functions in Python is straightforward.

They syntax is simply \texttt{def\ function\_name(arguments):}.

The following function squares two numbers.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ square(x):}
\NormalTok{    sq }\OperatorTok{=}\NormalTok{ x }\OperatorTok{**} \DecValTok{2}
    \ControlFlowTok{return}\NormalTok{(sq)}
\end{Highlighting}
\end{Shaded}

Let's verify that our function works.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(square(}\DecValTok{2}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(square(}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4
25
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Write a \texttt{cube()} function that cubes a
number, and along the way, verify that indentation is required after the
\texttt{def} statement.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ cube(x):}
\NormalTok{    cb }\OperatorTok{=}\NormalTok{ x }\OperatorTok{**} \DecValTok{3}
    \ControlFlowTok{return}\NormalTok{(cb)}

\BuiltInTok{print}\NormalTok{(cube(}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
27
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{option-payoff-function}{%
\section{Option Payoff Function}\label{option-payoff-function}}

Let's now write a more financially interesting function.

Options are insurance contracts that are written on top of an underlying
stock, much like car insurance is written \emph{on top} of your car.
There are two types of options: \emph{puts} and \emph{calls}. Put
options protect you from the stock price going too low, while call
options protect you from the stock price going too high. Both types have
a feature called a \emph{strike} price, which acts much like the
deductible of your car insurance. Options expire sometime in the future,
and the \emph{payoff} (payout) of the option at the time of the
expiration is as follows:

Let \(K\) be the strike price of an option, and let \(S_{T}\) price of
its underlying at the time of expiration. Then the payoff of each type
of option is as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{call}: \(\max(S_T - K, 0)\)
\item
  \textbf{put}: \(\max(K - S_T, 0)\)
\end{enumerate}

We can codify this as follows.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ option\_payoff(cp, strike, upx):}
    \ControlFlowTok{if}\NormalTok{ cp }\OperatorTok{==} \StringTok{\textquotesingle{}call\textquotesingle{}}\NormalTok{:}
\NormalTok{        payoff }\OperatorTok{=} \BuiltInTok{max}\NormalTok{(upx }\OperatorTok{{-}}\NormalTok{ strike, }\DecValTok{0}\NormalTok{)}
    \ControlFlowTok{elif}\NormalTok{ cp }\OperatorTok{==} \StringTok{\textquotesingle{}put\textquotesingle{}}\NormalTok{:}
\NormalTok{        payoff }\OperatorTok{=} \BuiltInTok{max}\NormalTok{(strike }\OperatorTok{{-}}\NormalTok{ upx, }\DecValTok{0}\NormalTok{)}
    
    \ControlFlowTok{return}\NormalTok{ payoff}
\end{Highlighting}
\end{Shaded}

Let's verify that our function works.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(option\_payoff(}\StringTok{"call"}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{110}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(option\_payoff(}\StringTok{"put"}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{110}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(option\_payoff(}\StringTok{"call"}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{90}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(option\_payoff(}\StringTok{"put"}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{90}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
0
0
10
\end{verbatim}

\hypertarget{loading-packages}{%
\section{Loading Packages}\label{loading-packages}}

Let's now load the packages that we will need.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\end{Highlighting}
\end{Shaded}

\hypertarget{reading-in-data-3}{%
\section{Reading-In Data}\label{reading-in-data-3}}

Next, let's read in a data file called
\texttt{spy\_expiring\_options.csv}.

This data set consists of 21 different options on \texttt{SPY} that
expired on November 16, 2018.

The \texttt{upx} column is the settle price of \texttt{SPY} from that
day, and it will be used to calculate the payoff of each of these
options.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_opt }\OperatorTok{=}\NormalTok{ pd.read\_csv(}\StringTok{"spy\_expiring\_options.csv"}\NormalTok{)}
\NormalTok{df\_opt }\OperatorTok{=}\NormalTok{ df\_opt.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{df\_opt.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllll@{}}
\toprule\noalign{}
& underlying & upx & type & expiration & data\_date & strike \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 270.0 \\
1 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 270.5 \\
2 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 271.0 \\
3 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 271.5 \\
4 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 272.0 \\
\end{longtable}

\hypertarget{initializing-payoff-columns}{%
\section{Initializing Payoff
Columns}\label{initializing-payoff-columns}}

Our ultimate objective is to add a column of option payoffs to
\texttt{df\_opt}. We are going to accomplish this task using two
different methods: (1) a \texttt{for} loop; (2) the
\texttt{DataFrame.apply()} method.

As a first step, let's add two columns to \texttt{df\_opt}, one for each
method, and then initialize them both with \texttt{np.nan}, which is a
special data type that represents missing numerical data.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_opt[}\StringTok{\textquotesingle{}payoff\_loop\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ np.nan}
\NormalTok{df\_opt[}\StringTok{\textquotesingle{}payoff\_apply\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ np.nan}
\NormalTok{df\_opt.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& underlying & upx & type & expiration & data\_date & strike &
payoff\_loop & payoff\_apply \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 270.0 & NaN & NaN \\
1 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 270.5 & NaN & NaN \\
2 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 271.0 & NaN & NaN \\
3 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 271.5 & NaN & NaN \\
4 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 272.0 & NaN & NaN \\
\end{longtable}

\hypertarget{calculate-payoff_loop-via-for-loop}{%
\section{\texorpdfstring{Calculate \texttt{payoff\_loop} via
\texttt{for}
loop}{Calculate payoff\_loop via for loop}}\label{calculate-payoff_loop-via-for-loop}}

Let's iterate through \texttt{df\_opt} with a \texttt{for} loop and
calculate the payoffs one by one. Notice that we are useing the
\texttt{.at} indexer which is specifically designed to grab a single
value from a column.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ ix }\KeywordTok{in}\NormalTok{ df\_opt.index:}
    
    \CommentTok{\# grabbing data from dataframe}
\NormalTok{    opt\_type }\OperatorTok{=}\NormalTok{ df\_opt.at[ix, }\StringTok{\textquotesingle{}type\textquotesingle{}}\NormalTok{]}
\NormalTok{    strike }\OperatorTok{=}\NormalTok{ df\_opt.at[ix, }\StringTok{\textquotesingle{}strike\textquotesingle{}}\NormalTok{]}
\NormalTok{    upx }\OperatorTok{=}\NormalTok{ df\_opt.at[ix, }\StringTok{\textquotesingle{}upx\textquotesingle{}}\NormalTok{]}
    
    \CommentTok{\# calculating payoff}
\NormalTok{    payoff }\OperatorTok{=}\NormalTok{ option\_payoff(opt\_type, strike, upx)}
    
    \CommentTok{\# writing payoff to dataframe}
\NormalTok{    df\_opt.at[ix, }\StringTok{\textquotesingle{}payoff\_loop\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ payoff}
      
\NormalTok{df\_opt}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& underlying & upx & type & expiration & data\_date & strike &
payoff\_loop & payoff\_apply \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 270.0 & 0.00 & NaN \\
1 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 270.5 & 0.00 & NaN \\
2 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 271.0 & 0.00 & NaN \\
3 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 271.5 & 0.00 & NaN \\
4 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 272.0 & 0.00 & NaN \\
5 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 272.5 & 0.00 & NaN \\
6 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 273.0 & 0.00 & NaN \\
7 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 273.5 & 0.00 & NaN \\
8 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 274.0 & 0.27 & NaN \\
9 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 274.5 & 0.77 & NaN \\
10 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 275.0 & 1.27 &
NaN \\
11 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 275.5 & 1.77 &
NaN \\
12 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 276.0 & 2.27 &
NaN \\
13 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 276.5 & 2.77 &
NaN \\
14 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 277.0 & 3.27 &
NaN \\
15 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 277.5 & 3.77 &
NaN \\
16 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 278.0 & 0.00 &
NaN \\
17 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 278.5 & 0.00 &
NaN \\
18 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 279.0 & 0.00 &
NaN \\
19 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 279.5 & 0.00 &
NaN \\
20 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 280.0 & 0.00 &
NaN \\
\end{longtable}

\hypertarget{calculate-payoff_apply-via-.apply}{%
\section{\texorpdfstring{Calculate \texttt{payoff\_apply} via
\texttt{.apply()}}{Calculate payoff\_apply via .apply()}}\label{calculate-payoff_apply-via-.apply}}

The \texttt{DataFrame.apply()} method allows us to perform these
calculations without explicitly iterating through \texttt{df\_opt} with
a \texttt{for} loop. It is a way to \emph{vectorize} user defined
functions.

In order to make use of \texttt{.apply()}, we will have to construct our
custom payoff function slightly differently. The following
\texttt{opt\_pay()} function expects as its argument the row of a
\texttt{DataFrame}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ opt\_pay(row):}
    \CommentTok{\# reading function inputs from DataFrame row}
\NormalTok{    cp }\OperatorTok{=}\NormalTok{ row[}\StringTok{\textquotesingle{}type\textquotesingle{}}\NormalTok{]}
\NormalTok{    strike }\OperatorTok{=}\NormalTok{ row[}\StringTok{\textquotesingle{}strike\textquotesingle{}}\NormalTok{]}
\NormalTok{    upx }\OperatorTok{=}\NormalTok{ row[}\StringTok{\textquotesingle{}upx\textquotesingle{}}\NormalTok{]}
    
    \CommentTok{\# option payoff logic}
    \ControlFlowTok{if}\NormalTok{ cp }\OperatorTok{==} \StringTok{\textquotesingle{}call\textquotesingle{}}\NormalTok{:}
\NormalTok{        payoff }\OperatorTok{=} \BuiltInTok{max}\NormalTok{(upx }\OperatorTok{{-}}\NormalTok{ strike, }\DecValTok{0}\NormalTok{)}
    \ControlFlowTok{elif}\NormalTok{ cp }\OperatorTok{==} \StringTok{\textquotesingle{}put\textquotesingle{}}\NormalTok{:}
\NormalTok{        payoff }\OperatorTok{=} \BuiltInTok{max}\NormalTok{(strike }\OperatorTok{{-}}\NormalTok{ upx, }\DecValTok{0}\NormalTok{)}
    
    \ControlFlowTok{return}\NormalTok{ payoff}
\end{Highlighting}
\end{Shaded}

We can use \texttt{.apply()} to calculate the payoffs in a single line
of code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_opt[}\StringTok{\textquotesingle{}payoff\_apply\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ df\_opt.}\BuiltInTok{apply}\NormalTok{(opt\_pay, axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{df\_opt}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& underlying & upx & type & expiration & data\_date & strike &
payoff\_loop & payoff\_apply \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 270.0 & 0.00 &
0.00 \\
1 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 270.5 & 0.00 &
0.00 \\
2 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 271.0 & 0.00 &
0.00 \\
3 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 271.5 & 0.00 &
0.00 \\
4 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 272.0 & 0.00 &
0.00 \\
5 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 272.5 & 0.00 &
0.00 \\
6 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 273.0 & 0.00 &
0.00 \\
7 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 273.5 & 0.00 &
0.00 \\
8 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 274.0 & 0.27 &
0.27 \\
9 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 274.5 & 0.77 &
0.77 \\
10 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 275.0 & 1.27 &
1.27 \\
11 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 275.5 & 1.77 &
1.77 \\
12 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 276.0 & 2.27 &
2.27 \\
13 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 276.5 & 2.77 &
2.77 \\
14 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 277.0 & 3.27 &
3.27 \\
15 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 277.5 & 3.77 &
3.77 \\
16 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 278.0 & 0.00 &
0.00 \\
17 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 278.5 & 0.00 &
0.00 \\
18 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 279.0 & 0.00 &
0.00 \\
19 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 279.5 & 0.00 &
0.00 \\
20 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 280.0 & 0.00 &
0.00 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Add a column to \texttt{df\_opt} that
identifies if the \texttt{upx} is bigger or smaller than
\texttt{strike}. Do this by writing a custom function and then using
\texttt{DataFrame.apply()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ big\_small(row):}
\NormalTok{    upx }\OperatorTok{=}\NormalTok{ row[}\StringTok{\textquotesingle{}upx\textquotesingle{}}\NormalTok{]}
\NormalTok{    strike }\OperatorTok{=}\NormalTok{ row[}\StringTok{\textquotesingle{}strike\textquotesingle{}}\NormalTok{]}
    
    \ControlFlowTok{if}\NormalTok{ upx }\OperatorTok{\textgreater{}=}\NormalTok{ strike:}
        \ControlFlowTok{return}\NormalTok{(}\StringTok{\textquotesingle{}bigger\textquotesingle{}}\NormalTok{)}
    \ControlFlowTok{else}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{(}\StringTok{\textquotesingle{}smaller\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_opt[}\StringTok{\textquotesingle{}big\_small\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ df\_opt.}\BuiltInTok{apply}\NormalTok{(big\_small, axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{df\_opt}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllll@{}}
\toprule\noalign{}
& underlying & upx & type & expiration & data\_date & strike &
payoff\_loop & payoff\_apply & big\_small \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 270.0 & 0.00 & 0.00 &
bigger \\
1 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 270.5 & 0.00 & 0.00 &
bigger \\
2 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 271.0 & 0.00 & 0.00 &
bigger \\
3 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 271.5 & 0.00 & 0.00 &
bigger \\
4 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 272.0 & 0.00 & 0.00 &
bigger \\
5 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 272.5 & 0.00 & 0.00 &
bigger \\
6 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 273.0 & 0.00 & 0.00 &
bigger \\
7 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 273.5 & 0.00 & 0.00 &
bigger \\
8 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 274.0 & 0.27 & 0.27 &
smaller \\
9 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 274.5 & 0.77 & 0.77 &
smaller \\
10 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 275.0 & 1.27 & 1.27
& smaller \\
11 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 275.5 & 1.77 & 1.77
& smaller \\
12 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 276.0 & 2.27 & 2.27
& smaller \\
13 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 276.5 & 2.77 & 2.77
& smaller \\
14 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 277.0 & 3.27 & 3.27
& smaller \\
15 & SPY & 273.73 & put & 2018-11-16 & 2018-11-16 & 277.5 & 3.77 & 3.77
& smaller \\
16 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 278.0 & 0.00 & 0.00
& smaller \\
17 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 278.5 & 0.00 & 0.00
& smaller \\
18 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 279.0 & 0.00 & 0.00
& smaller \\
19 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 279.5 & 0.00 & 0.00
& smaller \\
20 & SPY & 273.73 & call & 2018-11-16 & 2018-11-16 & 280.0 & 0.00 & 0.00
& smaller \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{related-reading-3}{%
\section{Related Reading}\label{related-reading-3}}

\emph{A Whirlwind Tour of Python} - Chapter 8 - Control Flow

\emph{A Whirlwind Tour of Python} - Chapter 9 - Defining Functions

\bookmarksetup{startatroot}

\hypertarget{merging-dataframes}{%
\chapter{\texorpdfstring{Merging
\texttt{DataFrames}}{Merging DataFrames}}\label{merging-dataframes}}

In this chapter we will learn how to \emph{merge} together two
\texttt{DataFrames}. In SQL this is referred to as \emph{joining}. The
effect of merging is similar to the lookup functions in Excel.

\hypertarget{loading-packages-1}{%
\section{Loading Packages}\label{loading-packages-1}}

Let's load the packages we will need for this tutorial.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\end{Highlighting}
\end{Shaded}

\hypertarget{reading-in-data-4}{%
\section{Reading-In Data}\label{reading-in-data-4}}

The data set we are going to use is a list of ETFs that have weekly
expiring options. What does that mean? Most stocks or ETFs have exchange
traded options that expire every month, and at any given time the
monthly expiring options go out about a year. The most liquid
underlyings have options that expire every week; these weekly expiring
options go out about 6-8 weeks.

This is a list that is published by the CBOE and it consists of all the
ETFs that have weekly options trading.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_weekly }\OperatorTok{=}\NormalTok{ pd.read\_csv(}\StringTok{\textquotesingle{}weekly\_etf.csv\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_weekly.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& ticker & name \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & AMJ & JP Morgan Alerian MLP Index ETN \\
1 & AMLP & Alerian MLP ETF \\
2 & ASHR & Xtrackers Harvest CSI 300 China A-Shares ETF \\
3 & DIA & SPDR Dow Jones Ind Av ETF Trust \\
4 & DUST & Direxion Daily Gold Miners Index Bear 3X Shares \\
\end{longtable}

The next data set that we are going to load is a comprehensive list of
all ETFs that are trading in the market.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf }\OperatorTok{=}\NormalTok{ pd.read\_csv(}\StringTok{"etf.csv"}\NormalTok{)}
\NormalTok{df\_etf.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& symbol & name & issuer & expense\_ratio & aum & spread & segment \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & SPY & SPDR S\&P 500 ETF Trust & State Street Global Advisors &
0.09\% & \$275.42B & 0.00\% & Equity: U.S. - Large Cap \\
1 & IVV & iShares Core S\&P 500 ETF & BlackRock & 0.04\% & \$155.86B &
0.01\% & Equity: U.S. - Large Cap \\
2 & VTI & Vanguard Total Stock Market ETF & Vanguard & 0.04\% &
\$103.58B & 0.01\% & Equity: U.S. - Total Market \\
3 & VOO & Vanguard S\&P 500 ETF & Vanguard & 0.04\% & \$96.91B & 0.01\%
& Equity: U.S. - Large Cap \\
4 & EFA & iShares MSCI EAFE ETF & BlackRock & 0.32\% & \$72.12B & 0.01\%
& Equity: Developed Markets Ex-U.S. - Total Market \\
\end{longtable}

\textbf{Motivation:} Notice that \texttt{df\_etf} has a \texttt{segment}
column which \texttt{df\_weekly} does not. This \texttt{segment} column
contains asset-class information that could be useful for categorizing
the weekly ETFs.

\textbf{Objective:} we want to get the \texttt{segment} column into
\texttt{df\_weekly}.

There are a couple of ways of accomplishing this in \textbf{pandas} and
both of them involve the \texttt{pd.merge()} method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \emph{inner-merge}
\item
  \emph{left/right-merge} (sometimes called \emph{outer merge})
\end{enumerate}

\hypertarget{inner}{%
\section{Inner}\label{inner}}

As with many of the basic operations in data analysis, it's easiest to
understand inner-merges by digging into an example.

Here is the line of code that accomplishes most of the work that we want
done:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.merge(df\_weekly, df\_etf, how}\OperatorTok{=}\StringTok{\textquotesingle{}inner\textquotesingle{}}\NormalTok{, left\_on}\OperatorTok{=}\StringTok{\textquotesingle{}ticker\textquotesingle{}}\NormalTok{, right\_on}\OperatorTok{=}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllll@{}}
\toprule\noalign{}
& ticker & name\_x & symbol & name\_y & issuer & expense\_ratio & aum &
spread & segment \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & AMJ & JP Morgan Alerian MLP Index ETN & AMJ & J.P. Morgan Alerian
MLP Index ETN & JPMorgan & 0.85\% & \$3.45B & 0.04\% & Equity: U.S.
MLPs \\
1 & AMLP & Alerian MLP ETF & AMLP & Alerian MLP ETF & ALPS & 0.85\% &
\$10.64B & 0.10\% & Equity: U.S. MLPs \\
2 & ASHR & Xtrackers Harvest CSI 300 China A-Shares ETF & ASHR &
Xtrackers Harvest CSI 300 China A-Shares ETF & Deutsche Bank & 0.65\% &
\$630.14M & 0.04\% & Equity: China - Total Market \\
3 & DIA & SPDR Dow Jones Ind Av ETF Trust & DIA & SPDR Dow Jones
Industrial Average ETF Trust & State Street Global Advisors & 0.17\% &
\$21.70B & 0.01\% & Equity: U.S. - Large Cap \\
4 & DUST & Direxion Daily Gold Miners Index Bear 3X Shares & DUST &
Direxion Daily Gold Miners Index Bear 3x Shares & Direxion & 1.08\% &
\$122.21M & 0.06\% & Inverse Equity: Global Gold Miners \\
... & ... & ... & ... & ... & ... & ... & ... & ... & ... \\
61 & XLV & HEALTH CARE SELECT SECTOR SPDR & XLV & Health Care Select
Sector SPDR Fund & State Street Global Advisors & 0.13\% & \$17.49B &
0.01\% & Equity: U.S. Health Care \\
62 & XLY & Consumer Discretionary Select Sector SPDR & XLY & Consumer
Discretionary Select Sector SPDR Fund & State Street Global Advisors &
0.13\% & \$14.35B & 0.01\% & Equity: U.S. Consumer Cyclicals \\
63 & XME & SPDR S\&P Metals \& Mining ETF & XME & SPDR S\&P Metals \&
Mining ETF & State Street Global Advisors & 0.35\% & \$879.10M & 0.03\%
& Equity: U.S. Metals \& Mining \\
64 & XOP & P Oil \& Gas Exploration \& Production ETF & XOP & SPDR S\&P
Oil \& Gas Exploration \& Production ETF & State Street Global Advisors
& 0.35\% & \$3.06B & 0.02\% & Equity: U.S. Oil \& Gas Exploration \&
Production \\
65 & XRT & SPDR S\&P Oil \& Gas Exploration \& Production ETF & XRT &
SPDR S\&P Retail ETF & State Street Global Advisors & 0.35\% & \$704.67M
& 0.02\% & Equity: U.S. Retail \\
\end{longtable}

\textbf{Observations on the syntax:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The first two arguments of \texttt{pd.merge()} are the two
  \texttt{DataFrames} we want to merge together. The first
  \texttt{DataFrame} is the \emph{left} \texttt{DataFrame} and the
  second one is the \emph{right} \texttt{DataFrame}.
\item
  The \texttt{how} argument defines the type of merge.
\item
  \texttt{left\_on} is the column in the left table that will be used
  for matching, \texttt{right\_on} is the column in the right table that
  will be used for matching.
\end{enumerate}

\textbf{Observations on output:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The output is basically each of the two tables smashed together,
  however only the rows with matching ticker/symbol are retained in the
  output. All columns of both tables are included.
\item
  \texttt{df\_weekly} had 67 rows in it, and \texttt{df\_etf} had 2,160
  row in it. The \texttt{DataFrame} that results from
  \texttt{pd.merge()} has 66 rows in it.
\item
  Notice that both \texttt{df\_weekly} and \texttt{df\_etf} have a
  column called \texttt{name}. In the merged \texttt{DataFrame},
  suffixes of \texttt{\_x} and \texttt{\_y} have been added to the
  column names to make them unique.
\end{enumerate}

Let's do a little clean up of our \texttt{DataFrame} so that it's just
the information that we wanted: \texttt{df\_weekly} with the
\texttt{segment} column added to it. Notice that \texttt{.merge()} is
also a \texttt{DataFrame} method, and we use this form to invoke method
chaining.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_inner }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    (}
\NormalTok{    df\_weekly}
\NormalTok{        .merge(df\_etf, how}\OperatorTok{=}\StringTok{\textquotesingle{}inner\textquotesingle{}}\NormalTok{, left\_on}\OperatorTok{=}\StringTok{\textquotesingle{}ticker\textquotesingle{}}\NormalTok{, right\_on}\OperatorTok{=}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{)}
\NormalTok{        [[}\StringTok{\textquotesingle{}ticker\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}name\_x\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}segment\textquotesingle{}}\NormalTok{]]}
\NormalTok{        .rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}name\_x\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}name\textquotesingle{}}\NormalTok{\})}
\NormalTok{    )}
\NormalTok{df\_inner}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& ticker & name & segment \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & AMJ & JP Morgan Alerian MLP Index ETN & Equity: U.S. MLPs \\
1 & AMLP & Alerian MLP ETF & Equity: U.S. MLPs \\
2 & ASHR & Xtrackers Harvest CSI 300 China A-Shares ETF & Equity: China
- Total Market \\
3 & DIA & SPDR Dow Jones Ind Av ETF Trust & Equity: U.S. - Large Cap \\
4 & DUST & Direxion Daily Gold Miners Index Bear 3X Shares & Inverse
Equity: Global Gold Miners \\
... & ... & ... & ... \\
61 & XLV & HEALTH CARE SELECT SECTOR SPDR & Equity: U.S. Health Care \\
62 & XLY & Consumer Discretionary Select Sector SPDR & Equity: U.S.
Consumer Cyclicals \\
63 & XME & SPDR S\&P Metals \& Mining ETF & Equity: U.S. Metals \&
Mining \\
64 & XOP & P Oil \& Gas Exploration \& Production ETF & Equity: U.S. Oil
\& Gas Exploration \& Production \\
65 & XRT & SPDR S\&P Oil \& Gas Exploration \& Production ETF & Equity:
U.S. Retail \\
\end{longtable}

\hypertarget{left}{%
\section{Left}\label{left}}

Notice that in the inner-join example from the previous section, the
original \texttt{DataFrame} of ETFs with weekly options
(\texttt{df\_weekly}) had 67 rows, but the merged \texttt{DataFrame}
with the \texttt{segment} column added (\texttt{df\_inner}) only has 66
rows.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df\_weekly.shape)}
\BuiltInTok{print}\NormalTok{(df\_inner.shape)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(67, 2)
(66, 3)
\end{verbatim}

So what happened? This means that one of the \texttt{tickers} from
\texttt{df\_weekly} had no matching \texttt{symbol} in \texttt{df\_etf}.

Inner-merges, by design, are only intended to retain rows that have
matches in both tables. This may or may not be the desired behavior you
are looking for.

Let's say that instead we wanted to keep \emph{ALL} the rows in the left
\texttt{DataFrame}, \texttt{df\_weekly}, irrespective of whether there
is a match in the right \texttt{DataFrame}.

This is precisely what a \emph{left-merge} is. The syntax is the exact
same as before except for the \texttt{how} argument is set to
\texttt{\textquotesingle{}left\textquotesingle{}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.merge(df\_weekly, df\_etf, how}\OperatorTok{=}\StringTok{\textquotesingle{}left\textquotesingle{}}\NormalTok{, left\_on}\OperatorTok{=}\StringTok{\textquotesingle{}ticker\textquotesingle{}}\NormalTok{, right\_on}\OperatorTok{=}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllll@{}}
\toprule\noalign{}
& ticker & name\_x & symbol & name\_y & issuer & expense\_ratio & aum &
spread & segment \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & AMJ & JP Morgan Alerian MLP Index ETN & AMJ & J.P. Morgan Alerian
MLP Index ETN & JPMorgan & 0.85\% & \$3.45B & 0.04\% & Equity: U.S.
MLPs \\
1 & AMLP & Alerian MLP ETF & AMLP & Alerian MLP ETF & ALPS & 0.85\% &
\$10.64B & 0.10\% & Equity: U.S. MLPs \\
2 & ASHR & Xtrackers Harvest CSI 300 China A-Shares ETF & ASHR &
Xtrackers Harvest CSI 300 China A-Shares ETF & Deutsche Bank & 0.65\% &
\$630.14M & 0.04\% & Equity: China - Total Market \\
3 & DIA & SPDR Dow Jones Ind Av ETF Trust & DIA & SPDR Dow Jones
Industrial Average ETF Trust & State Street Global Advisors & 0.17\% &
\$21.70B & 0.01\% & Equity: U.S. - Large Cap \\
4 & DUST & Direxion Daily Gold Miners Index Bear 3X Shares & DUST &
Direxion Daily Gold Miners Index Bear 3x Shares & Direxion & 1.08\% &
\$122.21M & 0.06\% & Inverse Equity: Global Gold Miners \\
... & ... & ... & ... & ... & ... & ... & ... & ... & ... \\
62 & XLV & HEALTH CARE SELECT SECTOR SPDR & XLV & Health Care Select
Sector SPDR Fund & State Street Global Advisors & 0.13\% & \$17.49B &
0.01\% & Equity: U.S. Health Care \\
63 & XLY & Consumer Discretionary Select Sector SPDR & XLY & Consumer
Discretionary Select Sector SPDR Fund & State Street Global Advisors &
0.13\% & \$14.35B & 0.01\% & Equity: U.S. Consumer Cyclicals \\
64 & XME & SPDR S\&P Metals \& Mining ETF & XME & SPDR S\&P Metals \&
Mining ETF & State Street Global Advisors & 0.35\% & \$879.10M & 0.03\%
& Equity: U.S. Metals \& Mining \\
65 & XOP & P Oil \& Gas Exploration \& Production ETF & XOP & SPDR S\&P
Oil \& Gas Exploration \& Production ETF & State Street Global Advisors
& 0.35\% & \$3.06B & 0.02\% & Equity: U.S. Oil \& Gas Exploration \&
Production \\
66 & XRT & SPDR S\&P Oil \& Gas Exploration \& Production ETF & XRT &
SPDR S\&P Retail ETF & State Street Global Advisors & 0.35\% & \$704.67M
& 0.02\% & Equity: U.S. Retail \\
\end{longtable}

Let's put this left-merged table into a \texttt{DataFrame} called
\texttt{df\_left}, and perform a bit of data munging.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_left }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    (}
\NormalTok{    df\_weekly}
\NormalTok{        .merge(df\_etf, how}\OperatorTok{=}\StringTok{\textquotesingle{}left\textquotesingle{}}\NormalTok{, left\_on}\OperatorTok{=}\StringTok{\textquotesingle{}ticker\textquotesingle{}}\NormalTok{, right\_on}\OperatorTok{=}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{)}
\NormalTok{        [[}\StringTok{\textquotesingle{}ticker\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}name\_x\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}segment\textquotesingle{}}\NormalTok{]]}
\NormalTok{        .rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}name\_x\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}name\textquotesingle{}}\NormalTok{\})}
\NormalTok{    )}
\NormalTok{df\_left}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& ticker & name & segment \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & AMJ & JP Morgan Alerian MLP Index ETN & Equity: U.S. MLPs \\
1 & AMLP & Alerian MLP ETF & Equity: U.S. MLPs \\
2 & ASHR & Xtrackers Harvest CSI 300 China A-Shares ETF & Equity: China
- Total Market \\
3 & DIA & SPDR Dow Jones Ind Av ETF Trust & Equity: U.S. - Large Cap \\
4 & DUST & Direxion Daily Gold Miners Index Bear 3X Shares & Inverse
Equity: Global Gold Miners \\
... & ... & ... & ... \\
62 & XLV & HEALTH CARE SELECT SECTOR SPDR & Equity: U.S. Health Care \\
63 & XLY & Consumer Discretionary Select Sector SPDR & Equity: U.S.
Consumer Cyclicals \\
64 & XME & SPDR S\&P Metals \& Mining ETF & Equity: U.S. Metals \&
Mining \\
65 & XOP & P Oil \& Gas Exploration \& Production ETF & Equity: U.S. Oil
\& Gas Exploration \& Production \\
66 & XRT & SPDR S\&P Oil \& Gas Exploration \& Production ETF & Equity:
U.S. Retail \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Use \texttt{.query()} on \texttt{df\_left} to
verify that \texttt{ticker} \texttt{FTK} has \texttt{NaNs} for all the
columns from \texttt{df\_etf}. Do this in two separate ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  querying on \texttt{ticker}
\item
  querying on \texttt{segment}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_left.query(}\StringTok{\textquotesingle{}ticker == "FTK"\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& ticker & name & segment \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
17 & FTK & FLOTEK INDUSTRIES INC & NaN \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_left.query(}\StringTok{\textquotesingle{}segment.isnull()\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& ticker & name & segment \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
17 & FTK & FLOTEK INDUSTRIES INC & NaN \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Research Challenge:} Google \texttt{FTK} and figure out why it's
not in \texttt{df\_etf}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# FTK is a stock not and ETF.}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{related-reading-4}{%
\section{Related Reading}\label{related-reading-4}}

\emph{Python Data Science Handboook} - Section 3.7 - Combining Datasets:
Merging and Joining

\bookmarksetup{startatroot}

\hypertarget{groupby-and-.agg---part-1}{%
\chapter{\texorpdfstring{\texttt{.groupby()} and \texttt{.agg()} - Part
1}{.groupby() and .agg() - Part 1}}\label{groupby-and-.agg---part-1}}

The real power of data analysis with \texttt{DataFrames} comes into
focus when we start utilizing the \texttt{.groupby()} and
\texttt{.agg()} methods. This is known as \emph{grouping} and
\emph{aggregating}.

Talking about grouping in the abstract can be confusing; I think it's
best to see grouping in action by doing meaningful calculations.

The purpose of this chapter is to introduce grouping and aggregation by
way of the following finance task: calculating monthly returns and
monthly volatilities for several ETFs.

\hypertarget{loading-packages-2}{%
\section{Loading Packages}\label{loading-packages-2}}

Let's begin by loading the packages that we will need.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ yfinance }\ImportTok{as}\NormalTok{ yf}
\NormalTok{yf.pdr\_override()}
\ImportTok{from}\NormalTok{ pandas\_datareader }\ImportTok{import}\NormalTok{ data }\ImportTok{as}\NormalTok{ pdr}
\end{Highlighting}
\end{Shaded}

\hypertarget{reading-in-data-5}{%
\section{Reading-In Data}\label{reading-in-data-5}}

Our analysis will be on the set of of July 2021 prices for \texttt{SPY},
\texttt{IWM}, \texttt{QQQ}, \texttt{DIA}.

Let's read-in that data with \textbf{pandas\_datareader}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.options.display.max\_rows }\OperatorTok{=} \DecValTok{25}
\NormalTok{df\_etf }\OperatorTok{=}\NormalTok{ pdr.get\_data\_yahoo([}\StringTok{\textquotesingle{}SPY\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}QQQ\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}IWM\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}DIA\textquotesingle{}}\NormalTok{], start}\OperatorTok{=}\StringTok{\textquotesingle{}2021{-}06{-}30\textquotesingle{}}\NormalTok{, end}\OperatorTok{=}\StringTok{\textquotesingle{}2021{-}07{-}31\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_etf }\OperatorTok{=}\NormalTok{ df\_etf.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{df\_etf.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[*********************100%***********************]  4 of 4 completed
\end{verbatim}

\begin{longtable}[]{@{}llllllllllllllllllllll@{}}
\toprule\noalign{}
&
\multicolumn{4}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 6\tabcolsep}}{%
Adj Close} &
\multicolumn{4}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 6\tabcolsep}}{%
Close} &
\multicolumn{2}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 2\tabcolsep}}{%
High} & ... &
\multicolumn{2}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 2\tabcolsep}}{%
Low} &
\multicolumn{4}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 6\tabcolsep}}{%
Open} &
\multicolumn{4}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 6\tabcolsep}@{}}{%
Volume} \\
& DIA & IWM & QQQ & SPY & DIA & IWM & QQQ & SPY & DIA & IWM & ... & QQQ
& SPY & DIA & IWM & QQQ & SPY & DIA & IWM & QQQ & SPY \\
Date & & & & & & & & & & & & & & & & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2021-06-30 & 331.30 & 223.29 & 349.98 & 415.28 & 344.95 & 229.37 &
354.43 & 428.06 & 345.51 & 230.32 & ... & 353.83 & 427.18 & 342.38 &
228.65 & 354.83 & 427.21 & 3778900 & 26039000 & 32724000 & 64827900 \\
2021-07-01 & 332.66 & 225.26 & 350.11 & 417.58 & 346.36 & 231.39 &
354.57 & 430.43 & 346.40 & 231.85 & ... & 352.68 & 428.80 & 345.78 &
230.81 & 354.07 & 428.87 & 3606900 & 18089100 & 29290000 & 53441000 \\
2021-07-02 & 334.17 & 223.11 & 354.13 & 420.77 & 347.94 & 229.19 &
358.64 & 433.72 & 348.29 & 232.08 & ... & 356.28 & 430.52 & 347.04 &
232.00 & 356.52 & 431.67 & 3013500 & 21029700 & 32727200 & 57697700 \\
2021-07-06 & 332.14 & 219.87 & 355.66 & 420.00 & 345.82 & 225.86 &
360.19 & 432.93 & 348.11 & 229.46 & ... & 356.49 & 430.01 & 347.75 &
229.36 & 359.26 & 433.78 & 3910600 & 27771300 & 38842400 & 68710400 \\
2021-07-07 & 333.20 & 217.83 & 356.41 & 421.49 & 346.92 & 223.76 &
360.95 & 434.46 & 347.14 & 226.67 & ... & 358.94 & 431.51 & 345.65 &
225.54 & 362.45 & 433.66 & 3347000 & 28521500 & 35265200 & 63549500 \\
\end{longtable}

This data is not as tidy as we would like. Let's use method chaining to
perform a series of data munging operations.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    (}
\NormalTok{    df\_etf}
\NormalTok{        .stack() }\CommentTok{\#pivot the table}
\NormalTok{        .reset\_index() }\CommentTok{\#turn date into a column}
\NormalTok{        .rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}level\_1\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}Symbols\textquotesingle{}}\NormalTok{\}) }\CommentTok{\#renaming a column}
\NormalTok{        .sort\_values(by}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}Symbols\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{]) }\CommentTok{\#sort}
\NormalTok{        .rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Symbols\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Adj Close\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}Close\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{, }
                         \StringTok{\textquotesingle{}High\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Low\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Open\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Volume\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{\}) }\CommentTok{\#renaming columns}
\NormalTok{        [[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{]] }\CommentTok{\#reordering columns}
\NormalTok{        .reset\_index(drop}\OperatorTok{=}\VariableTok{True}\NormalTok{)    }
\NormalTok{    )}
\NormalTok{df\_etf}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & DIA & 342.38 & 345.51 & 342.35 & 344.95 & 3778900 &
331.30 \\
1 & 2021-07-01 & DIA & 345.78 & 346.40 & 344.92 & 346.36 & 3606900 &
332.66 \\
2 & 2021-07-02 & DIA & 347.04 & 348.29 & 346.18 & 347.94 & 3013500 &
334.17 \\
3 & 2021-07-06 & DIA & 347.75 & 348.11 & 343.60 & 345.82 & 3910600 &
332.14 \\
4 & 2021-07-07 & DIA & 345.65 & 347.14 & 344.43 & 346.92 & 3347000 &
333.20 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
83 & 2021-07-26 & SPY & 439.31 & 441.03 & 439.26 & 441.02 & 43719200 &
427.85 \\
84 & 2021-07-27 & SPY & 439.91 & 439.94 & 435.99 & 439.01 & 67397100 &
425.90 \\
85 & 2021-07-28 & SPY & 439.68 & 440.30 & 437.31 & 438.83 & 52472400 &
425.73 \\
86 & 2021-07-29 & SPY & 439.82 & 441.80 & 439.81 & 440.65 & 47435300 &
427.49 \\
87 & 2021-07-30 & SPY & 437.91 & 440.06 & 437.77 & 438.51 & 68951200 &
425.42 \\
\end{longtable}

\hypertarget{daily-returns-with-groupby}{%
\section{\texorpdfstring{Daily Returns with
\texttt{groupby()}}{Daily Returns with groupby()}}\label{daily-returns-with-groupby}}

Our ultimate goal is to calculate monthly returns and monthly
volatilities for each ETF in \texttt{df\_etf}. These quantities are both
functions of daily returns. So our first order of business is to
calculate daily returns.

In a previous tutorial we calculated daily returns in a simple
vectorized fashion. Unfortunately, we can't use the exact same approach
here because there are multiple ETFs in the data set.

To overcome this challenge we will use our first application of
\texttt{.groupby()}.

Here is the \texttt{.groupby()} code that calculates daily returns for
each ETF.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# sorting values to get everything in the right order}
\NormalTok{df\_etf.sort\_values([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{], inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}

\CommentTok{\# vectorized return calculation}
\NormalTok{df\_etf[}\StringTok{\textquotesingle{}ret\textquotesingle{}}\NormalTok{] }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    df\_etf[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{].groupby(df\_etf[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{]).pct\_change()}
\NormalTok{df\_etf.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close &
ret \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & DIA & 342.38 & 345.51 & 342.35 & 344.95 & 3778900 &
331.30 & NaN \\
1 & 2021-07-01 & DIA & 345.78 & 346.40 & 344.92 & 346.36 & 3606900 &
332.66 & 0.004088 \\
2 & 2021-07-02 & DIA & 347.04 & 348.29 & 346.18 & 347.94 & 3013500 &
334.17 & 0.004562 \\
3 & 2021-07-06 & DIA & 347.75 & 348.11 & 343.60 & 345.82 & 3910600 &
332.14 & -0.006093 \\
4 & 2021-07-07 & DIA & 345.65 & 347.14 & 344.43 & 346.92 & 3347000 &
333.20 & 0.003181 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} If the \texttt{.group\_by()} worked correctly,
we should see a \texttt{NaN} value in the \texttt{ret} column for the
first trade-date of each ETF. Use \texttt{DataFrame.query()} to confirm
this.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf.query(}\StringTok{\textquotesingle{}ret.isnull()\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close &
ret \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & DIA & 342.38 & 345.51 & 342.35 & 344.95 & 3778900 &
331.30 & NaN \\
22 & 2021-06-30 & IWM & 228.65 & 230.32 & 227.76 & 229.37 & 26039000 &
223.29 & NaN \\
44 & 2021-06-30 & QQQ & 354.83 & 355.23 & 353.83 & 354.43 & 32724000 &
349.98 & NaN \\
66 & 2021-06-30 & SPY & 427.21 & 428.78 & 427.18 & 428.06 & 64827900 &
415.28 & NaN \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{monthly-return-for-each-symbol}{%
\section{\texorpdfstring{Monthly Return for Each
\texttt{symbol}}{Monthly Return for Each symbol}}\label{monthly-return-for-each-symbol}}

We'll now proceed to calculate monthly returns and monthly volatilities
for each of the ETFs in our data set. This amounts to first grouping by
\texttt{symbol}, and then performing an aggregation calculation on
\texttt{ret} (daily returns).

Let's start with monthly returns. As a preliminary step we'll calculate
the daily growth factor in a separate column.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf[}\StringTok{\textquotesingle{}daily\_factor\textquotesingle{}}\NormalTok{] }\OperatorTok{=} \DecValTok{1} \OperatorTok{+}\NormalTok{ df\_etf[}\StringTok{\textquotesingle{}ret\textquotesingle{}}\NormalTok{]}
\NormalTok{df\_etf.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close & ret
& daily\_factor \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2021-06-30 & DIA & 342.38 & 345.51 & 342.35 & 344.95 & 3778900 &
331.30 & NaN & NaN \\
1 & 2021-07-01 & DIA & 345.78 & 346.40 & 344.92 & 346.36 & 3606900 &
332.66 & 0.004088 & 1.004088 \\
2 & 2021-07-02 & DIA & 347.04 & 348.29 & 346.18 & 347.94 & 3013500 &
334.17 & 0.004562 & 1.004562 \\
3 & 2021-07-06 & DIA & 347.75 & 348.11 & 343.60 & 345.82 & 3910600 &
332.14 & -0.006093 & 0.993907 \\
4 & 2021-07-07 & DIA & 345.65 & 347.14 & 344.43 & 346.92 & 3347000 &
333.20 & 0.003181 & 1.003181 \\
\end{longtable}

Recall that the monthly growth factor is the product of the daily growth
factors. Here is a way to write all that logic in a single line using
\texttt{.groupby()} and \texttt{.agg()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_grouped\_factor }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    df\_etf.groupby([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}daily\_factor\textquotesingle{}}\NormalTok{].agg([np.prod]).reset\_index()}
\NormalTok{df\_grouped\_factor}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& symbol & prod \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & DIA & 1.013132 \\
1 & IWM & 0.963727 \\
2 & QQQ & 1.028609 \\
3 & SPY & 1.024412 \\
\end{longtable}

Notice that \textbf{pandas} isn't very sophisticated about the name that
it gives to the column that stores the aggregation calculation. It just
gave it the name \texttt{prod}, which is the name of the function that
was used in the aggregation calculation. Let's make
\texttt{df\_grouped\_factor} a bit more readable by renaming that
column.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_grouped\_factor.rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}prod\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}monthly\_factor\textquotesingle{}}\NormalTok{\}, inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{df\_grouped\_factor}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& symbol & monthly\_factor \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & DIA & 1.013132 \\
1 & IWM & 0.963727 \\
2 & QQQ & 1.028609 \\
3 & SPY & 1.024412 \\
\end{longtable}

And finally, recall that the monthly return is calculated by subtracting
one from the monthly growth factor.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_grouped\_factor[}\StringTok{\textquotesingle{}monthly\_return\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ df\_grouped\_factor[}\StringTok{\textquotesingle{}monthly\_factor\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}} \DecValTok{1}
\NormalTok{df\_grouped\_factor[[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}monthly\_return\textquotesingle{}}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& symbol & monthly\_return \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & DIA & 0.013132 \\
1 & IWM & -0.036273 \\
2 & QQQ & 0.028609 \\
3 & SPY & 0.024412 \\
\end{longtable}

\hypertarget{monthly-volatility-for-each-symbol}{%
\section{\texorpdfstring{Monthly Volatility for Each
\texttt{symbol}}{Monthly Volatility for Each symbol}}\label{monthly-volatility-for-each-symbol}}

Now let's calculate the (realized/historical) volatility for each of the
ETFs.

We once again use \texttt{.groupby()} and \texttt{.agg()} to do most of
the work in a single line of code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_grouped\_vol }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    df\_etf.groupby([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}ret\textquotesingle{}}\NormalTok{].agg([np.std]).reset\_index()}

\NormalTok{df\_grouped\_vol}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& symbol & std \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & DIA & 0.007733 \\
1 & IWM & 0.014032 \\
2 & QQQ & 0.006832 \\
3 & SPY & 0.007152 \\
\end{longtable}

Again, let's rename our aggregation column to something more
descriptive.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_grouped\_vol.rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}std\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}daily\_vol\textquotesingle{}}\NormalTok{\}, inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{df\_grouped\_vol}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& symbol & daily\_vol \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & DIA & 0.007733 \\
1 & IWM & 0.014032 \\
2 & QQQ & 0.006832 \\
3 & SPY & 0.007152 \\
\end{longtable}

What we have calculated is a daily volatility, but when practitioners
talk about volatility, they typically annualize it. A daily volatility
is annualized by multiplying by \(\sqrt{252}\).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_grouped\_vol[}\StringTok{\textquotesingle{}ann\_vol\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ df\_grouped\_vol[}\StringTok{\textquotesingle{}daily\_vol\textquotesingle{}}\NormalTok{] }\OperatorTok{*}\NormalTok{ np.sqrt(}\DecValTok{252}\NormalTok{)}
\NormalTok{df\_grouped\_vol}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& symbol & daily\_vol & ann\_vol \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & DIA & 0.007733 & 0.122752 \\
1 & IWM & 0.014032 & 0.222744 \\
2 & QQQ & 0.006832 & 0.108455 \\
3 & SPY & 0.007152 & 0.113542 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge} Use \texttt{.groupby()} and \texttt{.agg()} to
calculate the average daily return for each of the ETFs.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}
\NormalTok{df\_etf}
\NormalTok{    .groupby([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{])[[}\StringTok{\textquotesingle{}ret\textquotesingle{}}\NormalTok{]].agg(np.mean)}
\NormalTok{    .reset\_index()}
\NormalTok{    .rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}ret\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}daily\_avg\_ret\textquotesingle{}}\NormalTok{\})}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& symbol & daily\_avg\_ret \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & DIA & 0.000650 \\
1 & IWM & -0.001665 \\
2 & QQQ & 0.001366 \\
3 & SPY & 0.001174 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{related-reading-5}{%
\section{Related Reading}\label{related-reading-5}}

\emph{Python Data Science Handbook (VanderPlas)} - Section 3.8 -
Aggregation and Grouping

\emph{Python for Data Analysis (McKinney)} - Chapter 9 (pp 251-274) Data
Aggregation and Grouping Operations

\emph{Options, Futures, and Other Derivatives (Hull)} - Chapter 15 (pp
325-329) The Black-Scholes-Merton Model

\bookmarksetup{startatroot}

\hypertarget{groupby-and-.agg---part-2}{%
\chapter{\texorpdfstring{\texttt{.groupby()} and \texttt{.agg()} - Part
2}{.groupby() and .agg() - Part 2}}\label{groupby-and-.agg---part-2}}

The purpose of this chapter is to demonstrate how to use
\texttt{.groupby()} and \texttt{.agg()} with user defined functions.

In service of this objective our analysis goal will be to calculate
three monthly statistics for several ETFs during the year of 2020. The
three statistics we will calculate are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  average daily volume
\item
  monthly return
\item
  monthly volatility
\end{enumerate}

\hypertarget{loading-packages-3}{%
\section{Loading Packages}\label{loading-packages-3}}

Let's load the packages that we will need.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ yfinance }\ImportTok{as}\NormalTok{ yf}
\NormalTok{yf.pdr\_override()}
\ImportTok{from}\NormalTok{ pandas\_datareader }\ImportTok{import}\NormalTok{ data }\ImportTok{as}\NormalTok{ pdr}
\end{Highlighting}
\end{Shaded}

\hypertarget{reading-in-data-6}{%
\section{Reading-In Data}\label{reading-in-data-6}}

In this chapter we will be working with price data for the Select Sector
SPDR ETFs. Each of these funds tracks a particular subset (sector) of
the SP\&500 Index. For example, XLF tracks the financial sector and has
major holdings in JP Morgan, Wells Fargo, and Bank of America.

Let's use \textbf{pandas\_datareader} to grab the data from Yahoo
Finance.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.options.display.max\_rows }\OperatorTok{=} \DecValTok{25}
\NormalTok{lst\_symbols }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}XLY\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}XLP\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}XLE\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}XLF\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}XLV\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}XLI\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}XLB\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}XLRE\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}XLK\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}XLU\textquotesingle{}}\NormalTok{,]}
\NormalTok{df\_etf }\OperatorTok{=}\NormalTok{ pdr.get\_data\_yahoo(lst\_symbols, start}\OperatorTok{=}\StringTok{\textquotesingle{}2020{-}01{-}01\textquotesingle{}}\NormalTok{, end}\OperatorTok{=}\StringTok{\textquotesingle{}2020{-}12{-}31\textquotesingle{}}\NormalTok{)}
\NormalTok{df\_etf }\OperatorTok{=}\NormalTok{ df\_etf.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{df\_etf.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[*********************100%***********************]  10 of 10 completed
\end{verbatim}

\begin{longtable}[]{@{}llllllllllllllllllllll@{}}
\toprule\noalign{}
&
\multicolumn{10}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 18\tabcolsep}}{%
Adj Close} & ... &
\multicolumn{10}{>{\raggedright\arraybackslash}p{(\columnwidth - 42\tabcolsep) * \real{0.0000} + 18\tabcolsep}@{}}{%
Volume} \\
& XLB & XLE & XLF & XLI & XLK & XLP & XLRE & XLU & XLV & XLY & ... & XLB
& XLE & XLF & XLI & XLK & XLP & XLRE & XLU & XLV & XLY \\
Date & & & & & & & & & & & & & & & & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2020-01-02 & 56.50 & 51.06 & 28.88 & 78.28 & 90.25 & 57.09 & 34.06 &
57.12 & 96.64 & 123.04 & ... & 7357400 & 11944700 & 28843300 & 16121300
& 13283500 & 14460700 & 4380100 & 19107700 & 6277400 & 6295500 \\
2020-01-03 & 55.58 & 50.90 & 28.58 & 78.13 & 89.24 & 57.00 & 34.31 &
57.24 & 95.80 & 122.00 & ... & 12423200 & 29502900 & 51363600 & 17571300
& 15011800 & 26388900 & 3499000 & 17989300 & 8247500 & 5596400 \\
2020-01-06 & 55.34 & 51.30 & 28.56 & 78.15 & 89.45 & 57.12 & 34.32 &
57.29 & 96.39 & 122.34 & ... & 15764400 & 22458100 & 27956100 & 16153100
& 7815000 & 22541700 & 3097200 & 10444500 & 6441800 & 6411600 \\
2020-01-07 & 55.28 & 51.16 & 28.37 & 77.99 & 89.41 & 56.68 & 33.94 &
57.21 & 96.20 & 122.14 & ... & 20266900 & 11462500 & 39627500 & 16675400
& 7681800 & 15607600 & 3550600 & 13070300 & 6335300 & 9150800 \\
2020-01-08 & 55.47 & 50.32 & 28.56 & 78.26 & 90.37 & 56.89 & 34.11 &
57.19 & 96.83 & 122.51 & ... & 8079600 & 19021400 & 47966600 & 10677700
& 11627200 & 11451400 & 5089000 & 12741400 & 7494700 & 4725900 \\
\end{longtable}

This data is not as tidy as we would like. Let's use method chaining to
perform a series of data munging operations.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    (}
\NormalTok{    df\_etf}
\NormalTok{        .stack() }\CommentTok{\#pivot the table}
\NormalTok{        .reset\_index() }\CommentTok{\#turn date into a column}
\NormalTok{        .rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}level\_1\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}Symbols\textquotesingle{}}\NormalTok{\}) }\CommentTok{\#renaming a column}
\NormalTok{        .sort\_values(by}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}Symbols\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{]) }\CommentTok{\#sort}
\NormalTok{        .rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Symbols\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Adj Close\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}Close\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{, }
                         \StringTok{\textquotesingle{}High\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Low\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Open\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Volume\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{\}) }\CommentTok{\#renaming columns}
\NormalTok{        [[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}open\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}high\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}low\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}adj\_close\textquotesingle{}}\NormalTok{]] }\CommentTok{\#reordering columns}
\NormalTok{        .reset\_index(drop}\OperatorTok{=}\VariableTok{True}\NormalTok{)    }
\NormalTok{    )}
\NormalTok{df\_etf}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-01-02 & XLB & 61.83 & 61.94 & 60.63 & 60.70 & 7357400 &
56.50 \\
1 & 2020-01-03 & XLB & 60.08 & 60.44 & 59.70 & 59.72 & 12423200 &
55.58 \\
2 & 2020-01-06 & XLB & 59.55 & 59.83 & 59.41 & 59.46 & 15764400 &
55.34 \\
3 & 2020-01-07 & XLB & 59.36 & 59.80 & 59.20 & 59.39 & 20266900 &
55.28 \\
4 & 2020-01-08 & XLB & 59.40 & 59.84 & 59.20 & 59.60 & 8079600 &
55.47 \\
... & ... & ... & ... & ... & ... & ... & ... & ... \\
2515 & 2020-12-23 & XLY & 157.24 & 158.05 & 156.57 & 157.55 & 2173000 &
154.46 \\
2516 & 2020-12-24 & XLY & 157.70 & 158.12 & 157.21 & 157.88 & 1048800 &
154.79 \\
2517 & 2020-12-28 & XLY & 159.42 & 160.32 & 158.60 & 159.68 & 2912400 &
156.55 \\
2518 & 2020-12-29 & XLY & 160.24 & 160.53 & 158.98 & 159.73 & 2431200 &
156.60 \\
2519 & 2020-12-30 & XLY & 160.30 & 160.93 & 160.13 & 160.69 & 2440700 &
157.54 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Coding Challenge:} Use a \texttt{DataFrame} attribute to
determine the number of rows and columns in \texttt{df\_etf}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf.shape}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(2520, 8)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{exploring-and-cleaning-the-data}{%
\section{Exploring and Cleaning the
Data}\label{exploring-and-cleaning-the-data}}

As we can see from the coding challenge, this data set is large (by our
standards). Whenever I encounter a new data set that I can't look at in
its entirety, I like to do a bit of exploration via the built-in
\textbf{pandas} methods.

We know we have a variety of ETFs in our data, but it would be useful to
know how many (especially if we were expecting a certain number).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df\_etf[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{].unique())}
\BuiltInTok{print}\NormalTok{(df\_etf[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{].unique().size)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['XLB' 'XLE' 'XLF' 'XLI' 'XLK' 'XLP' 'XLRE' 'XLU' 'XLV' 'XLY']
10
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Coding Challenge:} What \texttt{DataFrame} attribute could we
use to check the data types of the columns of \texttt{df\_etf}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf.info()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 2520 entries, 0 to 2519
Data columns (total 8 columns):
 #   Column     Non-Null Count  Dtype         
---  ------     --------------  -----         
 0   date       2520 non-null   datetime64[ns]
 1   symbol     2520 non-null   object        
 2   open       2520 non-null   float64       
 3   high       2520 non-null   float64       
 4   low        2520 non-null   float64       
 5   close      2520 non-null   float64       
 6   volume     2520 non-null   int64         
 7   adj_close  2520 non-null   float64       
dtypes: datetime64[ns](1), float64(5), int64(1), object(1)
memory usage: 157.6+ KB
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

When I work with a time series of daily prices that I expect to come
from a certain date range, I like to check the first and last trade
dates that are represented in the data.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df\_etf[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{].}\BuiltInTok{min}\NormalTok{())}
\BuiltInTok{print}\NormalTok{(df\_etf[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{].}\BuiltInTok{max}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2020-01-02 00:00:00
2020-12-30 00:00:00
\end{verbatim}

Here is what we know about our data set thus far:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  10 different ETFs are represented.
\item
  Prices are coming from the entirety of 2020.
\end{enumerate}

Here are some things that we aren't necessarily sure of that would be
worth checking in a high-stakes situation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Is there a row/price for each symbol on each trade date?
\item
  Is there ever more than one row/price for a given symbol on a given
  trade date?
\end{enumerate}

We won't bother answering these questions for the purposes of this
chapter, but these are the types of data-integrity questions I will
often try to answer when encountering a new data set.

\hypertarget{calculating-daily-returns-with-groupby}{%
\section{\texorpdfstring{Calculating Daily Returns with
\texttt{groupby()}}{Calculating Daily Returns with groupby()}}\label{calculating-daily-returns-with-groupby}}

Our ultimate goal is to calculate monthly returns and monthly
volatilities for each ETF in \texttt{df\_etf}. These quantities are both
functions of daily returns. So our first order of business is to
calculate daily returns.

In a previous tutorial we calculated daily returns in a simple
vectorized fashion. Unfortunately, we can't use the exact same approach
here because there are multiple ETFs in the data set.

To overcome this challenge we will use our first application of
\texttt{.groupby()}.

Here is the \texttt{.groupby()} code that calculates daily returns for
each ETF.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# sorting values to get everything in the right order}
\NormalTok{df\_etf.sort\_values([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{], inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}

\CommentTok{\# vectorized return calculation}
\NormalTok{df\_etf[}\StringTok{\textquotesingle{}dly\_ret\textquotesingle{}}\NormalTok{] }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    df\_etf[}\StringTok{\textquotesingle{}close\textquotesingle{}}\NormalTok{].groupby(df\_etf[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{]).pct\_change()}
\NormalTok{df\_etf.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllll@{}}
\toprule\noalign{}
& date & symbol & open & high & low & close & volume & adj\_close &
dly\_ret \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-01-02 & XLB & 61.83 & 61.94 & 60.63 & 60.70 & 7357400 & 56.50 &
NaN \\
1 & 2020-01-03 & XLB & 60.08 & 60.44 & 59.70 & 59.72 & 12423200 & 55.58
& -0.016145 \\
2 & 2020-01-06 & XLB & 59.55 & 59.83 & 59.41 & 59.46 & 15764400 & 55.34
& -0.004354 \\
3 & 2020-01-07 & XLB & 59.36 & 59.80 & 59.20 & 59.39 & 20266900 & 55.28
& -0.001177 \\
4 & 2020-01-08 & XLB & 59.40 & 59.84 & 59.20 & 59.60 & 8079600 & 55.47 &
0.003536 \\
\end{longtable}

\hypertarget{adding-year-and-month-columns}{%
\section{\texorpdfstring{Adding \texttt{year} and \texttt{month}
Columns}{Adding year and month Columns}}\label{adding-year-and-month-columns}}

The ultimate goal is to calculate monthly statistics for each of the
ETFs in our data set.

As a preliminary step let's add a \texttt{month} and \texttt{year}
column to the \texttt{df\_etf} by utilizing the \texttt{.dt} attribute
that \textbf{pandas} provides for date columns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf[}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ df\_etf[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{].dt.year}
\NormalTok{df\_etf[}\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ df\_etf[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{].dt.month}
\NormalTok{df\_etf[[}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{]].head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& date & year & month \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2020-01-02 & 2020 & 1 \\
1 & 2020-01-03 & 2020 & 1 \\
2 & 2020-01-06 & 2020 & 1 \\
3 & 2020-01-07 & 2020 & 1 \\
4 & 2020-01-08 & 2020 & 1 \\
\end{longtable}

Let's do a quick data-integrity check: There are 10 ETFs in our data set
and there are 12 months in a year, so the number of symbol-year-month
combinations should be 120.

The following code counts the number of rows associated with each
symbol-year-month combination and puts that data into a
\texttt{DataFrame}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_num\_rows }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    df\_etf.groupby([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{]).size().reset\_index()}
\NormalTok{df\_num\_rows.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& symbol & year & month & 0 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & XLB & 2020 & 1 & 21 \\
1 & XLB & 2020 & 2 & 19 \\
2 & XLB & 2020 & 3 & 22 \\
3 & XLB & 2020 & 4 & 21 \\
4 & XLB & 2020 & 5 & 20 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Coding Challenge:} Confirm that there are the correct number of
symbol-year-month combinations in \texttt{df\_num\_rows}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_num\_rows.shape}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(120, 4)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Now that we've added the \texttt{year} and \texttt{month} columns we can
proceed to calculating our monthly statistics.

\hypertarget{average-daily-volume}{%
\section{Average Daily Volume}\label{average-daily-volume}}

Let's start with the most straight-forward calculation: average daily
volume, over each month, for all 10 of the ETFs in our data set.

This amounts to:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  grouping by \texttt{symbol}, \texttt{month}, and \texttt{year}
\item
  applying the built-in \texttt{np.mean()} function to the
  \texttt{volume} column
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_volume }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    df\_etf.groupby([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{].agg([np.mean]).reset\_index()}
\NormalTok{df\_volume.rename(columns}\OperatorTok{=}\NormalTok{\{}\StringTok{\textquotesingle{}mean\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}avg\_volume\textquotesingle{}}\NormalTok{\}, inplace}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{df\_volume.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& symbol & year & month & avg\_volume \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & XLB & 2020 & 1 & 7.235429e+06 \\
1 & XLB & 2020 & 2 & 1.058022e+07 \\
2 & XLB & 2020 & 3 & 1.432920e+07 \\
3 & XLB & 2020 & 4 & 9.000557e+06 \\
4 & XLB & 2020 & 5 & 4.829185e+06 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Coding Challenge:} Calculate the maximum daily volume for each
symbol, \emph{over the entire year}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_etf.groupby([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{].agg([np.}\BuiltInTok{max}\NormalTok{]).reset\_index()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& symbol & year & amax \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & XLB & 2020 & 30741700 \\
1 & XLE & 2020 & 99356700 \\
2 & XLF & 2020 & 256525000 \\
3 & XLI & 2020 & 79118200 \\
4 & XLK & 2020 & 61727100 \\
5 & XLP & 2020 & 50978800 \\
6 & XLRE & 2020 & 49899800 \\
7 & XLU & 2020 & 90263100 \\
8 & XLV & 2020 & 39561900 \\
9 & XLY & 2020 & 20616100 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{monthly-returns}{%
\section{Monthly Returns}\label{monthly-returns}}

Next, let's calculate monthly returns for each of the ETFs in our data
set. This amounts to:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  grouping by \texttt{symbol}, \texttt{month}, and \texttt{year}
\item
  applying an aggregation function to the \texttt{daily\_returns} column
\end{enumerate}

These are the same two steps that we have done in our previous
aggregation examples. However, there is one additional wrinkle that we
are going to have to contend with.

In the previous section, we used simple built-in aggregation funtions
available through \texttt{numpy}, such as \texttt{np.max} and
\texttt{np.mean}. Calculating monthly returns from daily returns is a
little more complicated.

Thus, we are going to have to first create a custom function for
calculating monthly returns from daily returns, and then use this custom
function in \texttt{.agg()}.

The following code defines our monthly returns function in terms of
daily returns:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ monthly\_ret(dly\_ret):}
    \ControlFlowTok{return}\NormalTok{ np.prod(}\DecValTok{1} \OperatorTok{+}\NormalTok{ dly\_ret) }\OperatorTok{{-}} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

Now we can apply our \texttt{monthly\_ret()} function for all of our
ETFs using the following code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_ret }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    df\_etf.groupby([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}dly\_ret\textquotesingle{}}\NormalTok{].agg([monthly\_ret]).reset\_index()}
\NormalTok{df\_ret.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& symbol & month & year & monthly\_ret \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & XLB & 1 & 2020 & -0.050577 \\
1 & XLB & 2 & 2020 & -0.085199 \\
2 & XLB & 3 & 2020 & -0.145675 \\
3 & XLB & 4 & 2020 & 0.151865 \\
4 & XLB & 5 & 2020 & 0.068813 \\
\end{longtable}

We can see from our calculation that in March of 2020 XLB had a monthly
return of -14.6\%.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Coding Challenge:} Which ETF had the highest single monthly
return in all of 2020? What was the month?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_ret.sort\_values(by}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}monthly\_ret\textquotesingle{}}\NormalTok{], ascending}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& symbol & month & year & monthly\_ret \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
15 & XLE & 4 & 2020 & 0.307639 \\
22 & XLE & 11 & 2020 & 0.279944 \\
111 & XLY & 4 & 2020 & 0.188825 \\
34 & XLF & 11 & 2020 & 0.168483 \\
46 & XLI & 11 & 2020 & 0.160274 \\
... & ... & ... & ... & ... \\
74 & XLRE & 3 & 2020 & -0.157380 \\
20 & XLE & 9 & 2020 & -0.159888 \\
38 & XLI & 3 & 2020 & -0.192529 \\
26 & XLF & 3 & 2020 & -0.216999 \\
14 & XLE & 3 & 2020 & -0.358074 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{monthly-volatility}{%
\section{Monthly Volatility}\label{monthly-volatility}}

Let's use a similar process to calculate the monthly volatility for each
of the ETFs.

We begin by defining a custom function that calculates the monthly
volatility from daily returns. Recall that industry convention is to
state these volatilities in annualized terms.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ monthly\_vol(dly\_ret):}
    \ControlFlowTok{return}\NormalTok{ np.std(dly\_ret) }\OperatorTok{*}\NormalTok{ np.sqrt(}\DecValTok{252}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can now use our \texttt{monthly\_vol()} function in to perform an
aggregating calculation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_vol }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    df\_etf.groupby([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}dly\_ret\textquotesingle{}}\NormalTok{].agg([monthly\_vol]).reset\_index()}
\NormalTok{df\_vol.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& symbol & month & year & monthly\_vol \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & XLB & 1 & 2020 & 0.150336 \\
1 & XLB & 2 & 2020 & 0.282201 \\
2 & XLB & 3 & 2020 & 0.932265 \\
3 & XLB & 4 & 2020 & 0.503394 \\
4 & XLB & 5 & 2020 & 0.277311 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Coding Challenge:} What was the volatility for XLF in December
2018?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_vol.query(}\StringTok{\textquotesingle{}symbol == "XLF" \& month == 12\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& symbol & month & year & monthly\_vol \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
35 & XLF & 12 & 2020 & 0.137471 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{combining-metrics---inner-.merge}{%
\section{\texorpdfstring{Combining Metrics - inner
\texttt{.merge()}}{Combining Metrics - inner .merge()}}\label{combining-metrics---inner-.merge}}

Now, suppose that we want to combine our three metrics into one report -
meaning that we want them organized into one \texttt{DataFrame} in an
easy to read fashion.

One way to do this is to use the \texttt{pandas.merge()} method that we
learned in the previous tutorial to join together \texttt{df\_volume}
(average daily volume), \texttt{df\_ret} (monthly returns), and
\texttt{df\_vol} (monthly volatility).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_joined }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    (}
\NormalTok{    df\_volume}
\NormalTok{        .merge(df\_ret, on}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{])}
\NormalTok{        .merge(df\_vol, on}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{])}
\NormalTok{    )}
\NormalTok{df\_joined.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllll@{}}
\toprule\noalign{}
& symbol & year & month & avg\_volume & monthly\_ret & monthly\_vol \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & XLB & 2020 & 1 & 7.235429e+06 & -0.050577 & 0.150336 \\
1 & XLB & 2020 & 2 & 1.058022e+07 & -0.085199 & 0.282201 \\
2 & XLB & 2020 & 3 & 1.432920e+07 & -0.145675 & 0.932265 \\
3 & XLB & 2020 & 4 & 9.000557e+06 & 0.151865 & 0.503394 \\
4 & XLB & 2020 & 5 & 4.829185e+06 & 0.068813 & 0.277311 \\
\end{longtable}

\hypertarget{combining-metrics---multiple-aggregation}{%
\section{Combining Metrics - multiple
aggregation}\label{combining-metrics---multiple-aggregation}}

Another way to combine all our statistics into a single
\texttt{DataFrame} is to supply all of our custom aggregation functions
as arguments to the \texttt{.agg()} function at the same time.

Here is what that looks like:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# defining aggregations}
\NormalTok{agg\_funcs }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    \{}\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{:[np.mean], }\StringTok{\textquotesingle{}dly\_ret\textquotesingle{}}\NormalTok{:[monthly\_ret, monthly\_vol]\}}

\CommentTok{\# performing all aggregations all three aggregations at once}
\NormalTok{df\_joined }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    df\_etf.groupby([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{]).agg(agg\_funcs).reset\_index()}

\CommentTok{\# looking at the data frame}
\NormalTok{df\_joined.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllll@{}}
\toprule\noalign{}
& symbol & month & year & volume &
\multicolumn{2}{>{\raggedright\arraybackslash}p{(\columnwidth - 12\tabcolsep) * \real{0.0000} + 2\tabcolsep}@{}}{%
dly\_ret} \\
& & & & mean & monthly\_ret & monthly\_vol \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & XLB & 1 & 2020 & 7.235429e+06 & -0.050577 & 0.150336 \\
1 & XLB & 2 & 2020 & 1.058022e+07 & -0.085199 & 0.282201 \\
2 & XLB & 3 & 2020 & 1.432920e+07 & -0.145675 & 0.932265 \\
3 & XLB & 4 & 2020 & 9.000557e+06 & 0.151865 & 0.503394 \\
4 & XLB & 5 & 2020 & 4.829185e+06 & 0.068813 & 0.277311 \\
\end{longtable}

Notice that the input into the \texttt{.agg()} method is a \texttt{dict}
whose elements are pairs that look like:

\texttt{\textquotesingle{}column\_name\textquotesingle{}:{[}list\_of\_aggregating\_functions}{]}.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Code Challenge:} Modify the code above to add maximum daily
volume to the report.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# defining aggregations}
\NormalTok{agg\_funcs }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    \{}\StringTok{\textquotesingle{}volume\textquotesingle{}}\NormalTok{:[np.mean, np.}\BuiltInTok{max}\NormalTok{], }\StringTok{\textquotesingle{}dly\_ret\textquotesingle{}}\NormalTok{:[monthly\_ret, monthly\_vol]\}}

\CommentTok{\# performing all aggregations all three aggregations at once}
\NormalTok{df\_joined }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    df\_etf.groupby([}\StringTok{\textquotesingle{}symbol\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{]).agg(agg\_funcs).reset\_index()}

\CommentTok{\# looking at the data frame}
\NormalTok{df\_joined.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& symbol & month & year &
\multicolumn{2}{>{\raggedright\arraybackslash}p{(\columnwidth - 14\tabcolsep) * \real{0.0000} + 2\tabcolsep}}{%
volume} &
\multicolumn{2}{>{\raggedright\arraybackslash}p{(\columnwidth - 14\tabcolsep) * \real{0.0000} + 2\tabcolsep}@{}}{%
dly\_ret} \\
& & & & mean & amax & monthly\_ret & monthly\_vol \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & XLB & 1 & 2020 & 7.235429e+06 & 20266900 & -0.050577 & 0.150336 \\
1 & XLB & 2 & 2020 & 1.058022e+07 & 30741700 & -0.085199 & 0.282201 \\
2 & XLB & 3 & 2020 & 1.432920e+07 & 28390200 & -0.145675 & 0.932265 \\
3 & XLB & 4 & 2020 & 9.000557e+06 & 30738000 & 0.151865 & 0.503394 \\
4 & XLB & 5 & 2020 & 4.829185e+06 & 7386300 & 0.068813 & 0.277311 \\
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{related-reading-6}{%
\section{Related Reading}\label{related-reading-6}}

\emph{Python Data Science Handbook (VanderPlas)} - Section 3.7 -
Combining Datasets: Merging and Joining

\emph{Python Data Science Handbook (VanderPlas)} - Section 3.8 -
Aggregation and Grouping

\emph{Python for Data Analysis (McKinney)} - Chapter 9 (pp 251-274) Data
Aggregation and Grouping Operations

\bookmarksetup{startatroot}

\hypertarget{references}{%
\chapter*{References}\label{references}}
\addcontentsline{toc}{chapter}{References}

\markboth{References}{References}

\hypertarget{refs}{}
\begin{CSLReferences}{0}{0}
\end{CSLReferences}



\end{document}
